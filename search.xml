<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[activemq队列模式下的多个消费者问题]]></title>
    <url>%2Factivemq%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于使用activemq多个消费者遇到的一些问题 问题最近在项目中使用了activemq进行消息的异步传递，只有一个消费者时，系统可以正常运行，但当增加多个消费者时，却只有一个消费者进行消费，其他的消费者不消费。 原因activemq有一个机制，叫消息预读取，这个机制默认会读取1000条消息发往一个消费者中，当超过1000消息堆积时，才会继续读取剩下的消息发往另一个消费者中。当只有一个消费者时，这个机制可以提高效率，但有多个消费者时，就不合适了，会导致其他消费者闲置。 解决办法在客户端的连接上，拼接jms.prefetchPolicy.all=xxx，就可以调整消息预读取条数，当有多个消费者时，可以适当的调低这个参数，保证其他消费者也可以消费到，从而提高消费速度。 完整的连接示例（以spring boot为例）： 1spring.activemq.broker-url=tcp://localhost:61616?jms.prefetchPolicy.all=2]]></content>
      <categories>
        <category>踩坑记</category>
      </categories>
      <tags>
        <tag>activemq</tag>
        <tag>消息队列</tag>
        <tag>多消费者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java序列化与反序列化]]></title>
    <url>%2Fjava%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Java中对象的序列化与反序列化 定义 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。 以上是摘自维基百科序列化的定义 通俗的讲，序列化，就是把程序中的对象信息，通过某种方式，存入硬盘或者其他介质中。而反序列化就是将存储的内容重新转换为对象。 序列化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TestSerialize &#123; @Test public void serialize() &#123; try (FileOutputStream fos = new FileOutputStream("a.clz"); ObjectOutputStream oos = new ObjectOutputStream(fos)) &#123; Student tom = new Student("tom", 99.5, 1); oos.writeObject(tom); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Student implements Serializable &#123; private String name; private Double score; private int sex; public Student() &#123; &#125; public Student(String name, Double score, int sex) &#123; this.name = name; this.score = score; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getScore() &#123; return score; &#125; public void setScore(Double score) &#123; this.score = score; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125;&#125; Java中的序列化很简单，直接使用java.io.ObjectOutputStream类的writeObject()方法即可。 执行完程序后，刷新当前项目文件夹，会有一个a.clz文件。 这里需要注意一点，要进行序列化，首先目标类必须实现Serializable接口。Serializable接口是一个空的接口，没有任何方法的定义，只是一个标记状态，表示可以进行序列化。 反序列化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TestSerialize &#123; @Test public void unSerialize() &#123; try (FileInputStream fis = new FileInputStream("a.clz"); ObjectInputStream ois = new ObjectInputStream(fis)) &#123; Student tom = (Student) ois.readObject(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Student implements Serializable &#123; private String name; private Double score; private int sex; public Student() &#123; &#125; public Student(String name, Double score, int sex) &#123; this.name = name; this.score = score; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getScore() &#123; return score; &#125; public void setScore(Double score) &#123; this.score = score; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125;&#125; 反序列化，使用java.io.ObjectInputStream类的readObject()方法即可。 serialVersionUID作用通常情况下，我们都会在实现序列化接口的同时，指定序列化id，就像这样 12345678910111213141516171819202122232425262728293031323334353637383940414243class Student implements Serializable &#123; /** * 指定序列化id */ private static final long serialVersionUID = -2284240240714138081L; private String name; private Double score; private int sex; public Student() &#123; &#125; public Student(String name, Double score, int sex) &#123; this.name = name; this.score = score; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getScore() &#123; return score; &#125; public void setScore(Double score) &#123; this.score = score; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125;&#125; 这里的serialVersionUID究竟有什么用？这里的序列化id，是方便修改了类后，反序列化时使用的。 下面我们做一个测试。 首先将类中的serialVersionUID移除，然后进行序列化。 修改目标类 Student，增加属性 school。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Student implements Serializable &#123; private String name; private Double score; private int sex; // 这是新增的 private String school; public Student() &#123; &#125; public Student(String name, Double score, int sex) &#123; this.name = name; this.score = score; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getScore() &#123; return score; &#125; public void setScore(Double score) &#123; this.score = score; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public String getSchool() &#123; return school; &#125; public void setSchool(String school) &#123; this.school = school; &#125;&#125; 进行反序列化 当修改了类后，反序列化抛出异常 123456789101112131415161718192021222324252627282930java.io.InvalidClassException: com.huayunworld.sas.Student; local class incompatible: stream classdesc serialVersionUID = -2284240240714138081, local class serialVersionUID = 7916950878587737932 at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:699) at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1885) at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1751) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2042) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1573) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:431) at com.huayunworld.sas.TestSerialize.unSerialize(TestSerialize.java:31) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) 原因分析：当未指定serialVersionUID时，在序列化时，Java会自动创建一个随机的long类型的数字当作serialVersionUID，而修改了类后，代码重新编译，又会生成一个新的serialVersionUID，反序列化时因为serialVersionUID不同，所以导致反序列化失败。 当手动指定了serialVersionUID后，就不会出现反序列化失败了，大家可以自行测试验证。 transient关键字当类的中的某些字段不想被序列化时，可以使用transient关键字进行修饰。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Student implements Serializable &#123; private static final long serialVersionUID = 7916950878587737932L; private String name; private Double score; private int sex; // 使用transient关键字修饰，表示此字段不参与序列化 private transient String school; public Student() &#123; &#125; public Student(String name, Double score, int sex) &#123; this.name = name; this.score = score; this.sex = sex; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getScore() &#123; return score; &#125; public void setScore(Double score) &#123; this.score = score; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; public String getSchool() &#123; return school; &#125; public void setSchool(String school) &#123; this.school = school; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>序列化</tag>
        <tag>反序列化</tag>
        <tag>Serializable</tag>
        <tag>serialVersionUID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis拦截器]]></title>
    <url>%2Fmybatis%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[使用mybatis自定义sql拦截器实现分表 背景介绍有这么一个场景，有一套文件上传系统，多个用户上传文件时，会记录用户的上传文件位置和文件的其他信息。 文件上传记录表结构如下： 字段编码 字段说明 id 主键 user_code 用户编码 file_name 文件名 file_path 文件存储路径 …… …… 隐藏的问题上面的这种表结构，在存数据时不会有什么太大的问题，但是当数据量非常大的时候，查询速度会变慢。 解决思路通过 用户编码_表名 的方式来分表，将单张表的数据，拆分成多张表。在查询的时候，动态拼接表名。 具体写法创建一个类，实现org.apache.ibatis.plugin.Interceptor接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Intercepts(&#123;@Signature(type = StatementHandler.class, method = "prepare", args = &#123;Connection.class, Integer.class&#125;)&#125;)public class MyBatisInterceptor implements Interceptor &#123; /** * 存放需要拦截的表 */ private Set&lt;String&gt; tables = new HashSet&lt;&gt;(); /** * 拦截sql方法 */ @Override public Object intercept(Invocation invocation) throws Throwable &#123; StatementHandler statementHandler = (StatementHandler) invocation.getTarget(); BoundSql boundSql = statementHandler.getBoundSql(); // 获取sql请求参数 Object parameterObject = statementHandler.getParameterHandler().getParameterObject(); Map&lt;String, Object&gt; parameter = MapUtils.objectToMap(parameterObject); /*MetaObject metaObject = MetaObject.forObject(statementHandler, SystemMetaObject.DEFAULT_OBJECT_FACTORY, SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY, new DefaultReflectorFactory()); MappedStatement mappedStatement = (MappedStatement) metaObject.getValue("delegate.mappedStatement"); //id为执行的mapper方法的全路径名，如com.zhangjava.UserDao.insertUser String id = mappedStatement.getId(); //sql语句类型 select、delete、insert、update String sqlCommandType = mappedStatement.getSqlCommandType().toString(); System.out.println(sqlCommandType);*/ //获取到原始sql语句 String sql = boundSql.getSql(); // 获取用户编码 String userCode = getUserCode(parameter); for (String table : tables) &#123; // 替换表名 sql = sql.replaceAll(table, userCode + "_" + table); &#125; //通过反射修改sql语句 Field field = boundSql.getClass().getDeclaredField("sql"); field.setAccessible(true); field.set(boundSql, sql); return invocation.proceed(); &#125; @Override public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; /** * 获取配置文件配置的属性 * * @param properties */ @Override public void setProperties(Properties properties) &#123; String tableStr = properties.getProperty("tables"); if (StringUtils.isNotBlank(tableStr)) &#123; String[] split = tableStr.split(","); for (String s : split) &#123; s = s.trim(); if (StringUtils.isNotBlank(s)) &#123; tables.add(s); &#125; &#125; &#125; &#125;&#125; 修改mybatis的配置文件，增加如下配置 123456&lt;!-- sql拦截器 按照用户编码切表，表名小写，多个表使用英文,分割 --&gt;&lt;plugins&gt; &lt;plugin interceptor="com.zhangjava.conf.interceptor.MyBatisInterceptor"&gt; &lt;property name="tables" value="upload_audio"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 这样在写sql时，不需要传入参数去拼接表，直接通过拦截器就可以动态拼接表名。]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>拦截器</tag>
        <tag>分表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot打成war包发布]]></title>
    <url>%2FSpringBoot%E6%89%93%E6%88%90war%E5%8C%85%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[本文介绍了将SpringBoot打成war包的具体操作步骤 前言在使用SpringBoot时，我们一般都是将SpringBoot打包成jar包，然后直接使用 1java -jar xxx.jar 的方式运行，但有时候可能会因为其他问题，需要放到tomcat中运行。 例如：甲方服务器只开放一个8080端口供外部使用，而我们的项目有好多个都需要外网访问，这样就必须将多个项目放入同一个tomcat，用路径去区分访问了。 具体步骤修改maven打包方式12&lt;!-- 修改打包方式为war --&gt;&lt;packaging&gt;war&lt;/packaging&gt; 移除内嵌的tomcat12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 移除内部tomcat插件 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 增加servlet依赖1234567&lt;!-- 增加servlet依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 修改启动类在原来的启动类同级目录下，新建一个类，继承SpringBootServletInitializer，并重写configure方法 12345678910/** * 使用tomcat方式启动 */public class TomcatApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; // 这里的 CollectApplication 就是原来的启动类 return builder.sources(CollectApplication.class); &#125;&#125; 打包部署使用maven打包，将打包好的war包放入tomcat的webapps 下，启动tomcat即可。 可能遇到的问题如果你使用的是tomcat7启动，可能会报如下错误： 1java.lang.NoClassDefFoundError: javax/el/ELManager 解决方法1：直接使用tomcat8 解决办法2：下载el-api3.0.jar包，放入tomcat的lib中。这里是下载链接 或者从tomcat8的lib包中，拷贝el-api.jar放入tomcat7的lib中]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>war</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux历史记录，输出重定向等命令]]></title>
    <url>%2FLinux%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%EF%BC%8C%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E7%AD%89%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[其他杂项命令 常用命令 1.历史记录 history[选项][历史命令保存文件]history用于查看当前登录用户的操作历史记录，文件在 ~ 下的 .bash_history -c: 清空历史命令 -w: 把缓存中的历史命令写入到 .bash_history文件中 例子1history -w /home/zhangxu/myhistory将历史记录写入指定文件中 例子2history -w将历史记录写入默认文件中(.bash_history) 修改历史记录默认条数历史记录的默认条数在linux的环境变量配置文件 /etc/profile 中 HISTSIZE=1000,默认是1000条 历史命令的调用 使用上、下箭头调用以前的历史命令 使用 !n 重复执行第n条历史领命 使用 !! 重复执行上一条命令 使用 !字符串 重复执行最后一条以该字符串开头的命令 2.别名 命令执行优先级1.用绝对路径或相对路径执行的命令2.使用别名执行的命令3.执行bash内部命令4.按照$PATH环境变量定义的目录查找顺序找到的第一个命令 添加和修改临时别名 使用 alias命令添加别名 alias vi=’vim’ 使用 unalias 删除别名 unalias vi 用这种方式添加的别名，下次登陆后就不存在了，属于临时别名 让别名永久生效 编辑 ~/.bashrc 文件，添加别名，使别名永久生效 3.快捷键 bash常用快捷键 快捷键 作用 CTRL+A 将光标移动到命令行开头 CTRL+E 将光标移动到命令行结尾 CTRL+C 强行终止当前命令 CTRL+L 清屏，相当于clear CTRL+U 删除或剪切光标之前的命令 CTRL+K 删除或剪切光标之后的命令 CTRL+Y 粘贴CTRL+U或者CTRL+K剪切的内容 CTRL+R 在历史命令中搜索 CTRL+D 退出当前终端 CTRL+Z 暂停，并放入后台 CTRL+S 暂停屏幕输出 CTRL+Q 恢复屏幕输出 4.输出重定向 标准输入输出 设备 设备文件名 文件描述符 类型 键盘 /dev/stdin 0 标准输入 显示器 /dev/sdtout 1 标准输出 显示器 /dev/sdterr 2 标准输出错误 输出重定向1 类型 符号 作用 标准输出重定向 命令 &gt; 文件 以覆盖的方式，把命令正确输出到指定的文件或设备中 命令 &gt;&gt; 文件 以追加的方式，把命令正确输出到指定的文件或设备中 标准错误输出重定向 错误命令 2&gt;文件 以覆盖的方式，把命令错误输出到指定的文件或设备中 错误命令 2&gt;&gt;文件 以追加的方式，把命令错误输出到指定的文件或设备中 ​ 输出重定向2 符号 作用 命令 &gt; 文件 2&gt;&amp;1 以覆盖的方式，把正确输出和错误输出都保存到同一个文件中 命令 &gt;&gt; 文件 2&gt;&amp;1 以追加的方式，把正确输出和错误输出都保存到同一个文件中 命令 &amp;&gt; 文件 以覆盖的方式，把正确输出和错误输出都保存到同一个文件中 命令 &amp;&gt;&gt; 文件 以追加的方式，把正确输出和错误输出都保存到同一个文件中 命令&gt;&gt;文件1 2&gt;&gt;文件2 以追加的方式，把正确输出保存到文件1中，错误输出保存到文件2中 输出重定向3特殊用法：ls &amp;&gt;/dev/null不保存输出结果，将输出结果丢入垃圾箱 5.输入重定向 wc[选项][文件名] -c 统计字节数 -w 统计单词数 -l 统计行数 例子：输入：wc &lt; a.txt输出：1(行数) 2(单词数) 4(字节数) 特殊用法 统计某个文件夹下有多少文件ls 文件夹名 |wc -w 6.多命令顺序执行 多命令执行符 格式 作用 ; 命令1;命令2 多个命令顺序执行，命令之间没有 任何逻辑联系 &amp;&amp; 命令1&amp;&amp;命令2 逻辑与；当命令1正确执行，命令2才会执行；当命令1执行不正确，命令2不会执行 \ \ 命令1 \ \ 命令2 逻辑或；当命令1执行不正确，则执行命令2；当命令1执行正确，命令2不执行 硬盘数据复制 dd if=输入文件 of=输出文件 bs=字节数 count=个数 选项 if=输入文件 指定源文件或源设备 of=输出文件 指定目标文件或目标设备 bs=字节数 指定一次输入/输出多少字节，即把这些字节看作一个数据块 count=个数 指定输入/输出多少个数据块 例子：date;dd if=/dev/zero of=/root/testfile bs=1k count=100000;date; 7.管道符 命令1 | 命令2命令1的正确输出作为命令2的操作对象 例子 ll -a /etc/ | more netstat -an|grep “ESTABLISHED” 8.grep命令 grep[选项]”搜索内容” 文件名 选项 -i：忽略大小写 -n：输出行号 -v：反向查找 –color=auto 搜索出的关键字用颜色显示 例子 grep -n –color=auto “phone” readme.txt 9.通配符 通配符 作用 ？ 匹配一个任意字符 * 匹配0个或任意多个字符，也就是匹配任何内容 [] 匹配括号中任意字符。例如：[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c [-] 匹配括号中任意一个字符。代表一个范围。例如：[a-z]代表匹配26个英文字母中任意一个小写字母 [^] 逻辑非，表示匹配不是括号内的一个字符。例如代[ ^0-9 ]表匹配一个不是数字的字符 10.进程 查看进程 ps -ef查看所有进程 ps -aux查看正在运行的进程 杀死进程 kill -9 进程id 11.重启系统 关机 poweroff shutdown -h now init 0 重启 reboot init 6 设置系统启动方式 vi /etc/inittab 1id:3:initdefault: 3 是以字符界面启动5 是以图形化界面启动 12.磁盘操作 显示系统的磁盘空间用量 df -h //显示磁盘分区信息 mkfs.ext4 /dev/sdb1 //格式化具体磁盘分区 fdisk -l //查看磁盘分区 fdisk /dev/sdb1 //查看具体的磁盘信息 du -h -s 目录 //查看目录使用大小 挂载 mount -t vfat /dev/sdb1 /media/umnt //挂载 mount -o remount rw / //重新挂载，或者将根目录以读写方式重新加载 umount /media/umnt //卸载 文件系统修复 fsck -y /dev/sda1 (修复的可以是分区也可以是目录，最好在单用户模式下使用) 13.用户和组的操作 账户 超级账户 root uid=0 普通账户 uid&gt;=500 系统账户 uid=1~499 /etc/passwd 保存账户的信息 /etc/shadow 保存账户密码信息 /root root家目录 /home/xxx 普通用户 xxx 的家目录 添加和删除用户 useradd 用户名 //创建用户 -u 指定uid -d 指定宿主目录 -s 指定使用shell -e 指定用户过期时间 -g 指定基本组 -G 指定附加组 userdel 用户名 //删除用户，不删除用户目录 -r 连用户目录一起删除 用户组操作 gpasswd -a tom jerry //将tom添加到jerry组 gpasswd -d tom jerry //将tom移出jerry组 groups tom //查看tom在哪个组 修改用户密码 passwd 用户名 修改用户权限 usermod -L 用户名 //锁定用户，禁止登录 usermod -U 用户名 ///解锁用户 切换用户 su 用户名 //切换到指定用户]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>grep</tag>
        <tag>history</tag>
        <tag>kill</tag>
        <tag>df</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux压缩包操作，查找命令]]></title>
    <url>%2FLinux%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux压缩包操作，查找命令 压缩包操作，查找命令1.打包压缩 打 tar/tar.gz 包 -z 压缩 -c 打包 -x 解包 -f 必须要 -C 指定解包位置 -v 输出信息 tar -zcvf down.tar ./Download 将Download打包到当前目录 tar -zxvf down.tar 将down.tar解压到当前目录 zip 包 unzip 解包 1unzip text.zip #将text.zip解压到当前目录下 zip 打包 1zip text.zip note/ Download/ -r #将note Download 文件夹打包成text.zip包 2.查找 查找命令所在路径 which zip 查找命令安装路径 whereis ls 查找文件-效率很快(用的是数据库) locate httpd.conf #查找文件所在路径 updatedb #更新数据库 查找文件-效率较低 find / -name zip]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>压缩包</tag>
        <tag>查找命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件操作]]></title>
    <url>%2FLinux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Linux文件操作 linux文件操作1.创建文件和目录 mkdir /home/file 创建空文件夹 mkdir -p /home/file/picture 递归创建空文件夹 touch /home/file/a.txt 创建空文件 vi /home/file/a.txt 创建空文件，并进入编辑模式 2.查看文件 cat 文件名 查看所有文件内容 -n 查看所有文件内容，显示行号 tail 文件名 查看文件最后10行数据 -20 查看文件最后20行数据 -f 实时监控文件内容 head 文件名 查看文件头10行数据 -20 查看文件前20行数据 more 文件名 以百分比的形式查看文件内容，不可回滚 less 文件名 查看文件内容，可以回滚 3.复制文件 cp /usr/a /home/b 将文件a复制到文件夹/home/b中 cp -r /home/file /home/file1 将文件夹file复制到file1中 4.移动文件 mv /home/a /home/b 5.删除文件 rm 文件名 删除文件 -r 删除目录 -f 强制删除 -rf 强制删除文件目录]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux防火墙、软件安装管理]]></title>
    <url>%2FLinux%E9%98%B2%E7%81%AB%E5%A2%99%E3%80%81%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux防火墙，软件安装 防火墙，软件安装管理1.防火墙操作 防火墙的启动与停止 service iptables start 启动防火墙服务 service iptables stop 关闭防火墙 service iptables restart 重启防火墙 开放某个端口通过防火墙 vi /etc/sysconfig/iptables 编辑添加指定端口 2.设置服务开机启动 chkconfig xxx on 1chkconfig tomcat on 开机启动tomcat chkconfig xxx of chkconfig tomcat off 禁止开机启动 查看某个服务是否开机启动 chkconfig tomcat --list 3.rpm软件安装 二进制包直接解压，配置 /etc/profile 配置文件就能使用 rpm 安装 -i install的意思 -q query查询 -a all所有 -v 显示附加信息 -h 安装时输出标记”#” –test 只对安装进行测试，并不实际安装 –nodeps 不检查软件之间的依赖关系，加入此选项可能会导致软件不可用 –force 忽略软件包及软件冲突 –replacepkgs 强制重新安装已经安装的软件包 –prefix 将软件包安装到指定的路径下 –percent 以百分比的形式输出安装的进度 –exclueddocs 不安装软件包中的说明文件 –includedocs 安装软件包，包含说明文件 re&gt;m -ivh nc.rpm #安装示例 rpm 校验包 rpm -Vp 软件包名 rpm 检查更新包 rpm -Uvh mysql-community-release-el6-5.noarch.rpm rpm 删除包 rmp -e mysql-community-release-el6-5.noarch.rpm 4.yum 安装软件包 安装 yum install package1 安装软件package1 yum groupinstall group1 安装程序组group1 更新和升级 yum -y update 升级所有包，改变软件设置和系统设置，系统版本内核都升级 yum -y upgrade 升级所有包，不改变软件设置和系统设置，系统版本升级，内核不变 yum update package1 更新软件package1 yum upgrade package1 更新软件package1 yum check-update 检查可更新的程序 yum groupupdate group1 更新程序组group1 查找和显示 yum info package1 显示package1安装包信息 yum list 显示所有已经安装和可以安装的程序包 yum list package1 显示package1安装包情况 yum grouplist 显示所有已经安装和可以安装的程序组 yum groupinfo group1 显示程序组group1信息 yum search string 根据关键字string查找安装包 删除程序 yum remove/erase package1 删除程序package1 yum groupremove group1 删除程序组group1 yum deplist package1 查看程序package1依赖情况 清除缓存 yum clean packages 清除缓存目录下的软件包 yum clean headers 清除缓存目录下的headers yum clean all 清除缓存目录下所有的旧软件包 yum makecache 重新构建缓存 5.源码包安装 解压源码包 找到源码包下的configure，并执行 [root@centos6 bashdb-4.4-0.94]# ./configure 当configure执行成功时，会在当前目录下生成Makefile文件 使用make命令编译源码 [root@centos6 bashdb-4.4-0.94]# make make install 安装包 [root@centos6 bashdb-4.4-0.94]# make install]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>软件安装</tag>
        <tag>防火墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud-2-服务提供与调用]]></title>
    <url>%2FSpringCloud-2-%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E4%B8%8E%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[服务提供与调用]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud(1)-注册与发现(Eureka)]]></title>
    <url>%2FSpringCloud-1-%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0-Eureka%2F</url>
    <content type="text"><![CDATA[使用Eureka实现注册中心 什么是注册中心注册中心就相当于一个管家，当我们的系统随着业务规模越来越大时，系统之间的相互调用也会越来越复杂。而且各个子系统出于高可用的目的，可能会有多个实例，当某个子系统出现了故障，要自动切换到备用的系统。注册中心就是处理这些问题的。 项目搭建创建父项目创建一个maven项目，作为父项目。删除src目录，只留pom文件。 修改pom文件，引入springboot与springcloud依赖 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;groupId&gt;com.zhangjava.cloud2&lt;/groupId&gt;&lt;artifactId&gt;cloud2&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;!-- springcloud版本 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 注意springcloud与springboot的版本号要对应。父项目要修改打包方式为pom: &lt;packaging&gt;pom&lt;/packaging&gt; 创建注册中心创建springboot module，修改pom继承自cloud2 12345678910111213141516171819202122232425&lt;parent&gt; &lt;groupId&gt;com.zhangjava.cloud2&lt;/groupId&gt; &lt;artifactId&gt;cloud2&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/parent&gt;&lt;artifactId&gt;register&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;name&gt;register&lt;/name&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;!-- 注意这是 server --&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 修改application.properties配置文件 12345678910111213#端口号server.port=8085#服务名称spring.application.name=eureka-register#地址eureka.instance.hostname=localhost#禁止自己注册自己eureka.client.register-with-eureka=false#禁止自己获取注册信息eureka.client.fetch-registry=false#向外暴露注册地址eureka.client.service-url.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 在启动类上加入@EnableEurekaServer注解即可。 启动项目后，访问localhost:8085，看到如下页面，表示启动成功。 创建服务提供者创建springboot module，修改pom继承自cloud2 12345678910111213141516171819202122232425262728293031&lt;parent&gt; &lt;groupId&gt;com.zhangjava.cloud2&lt;/groupId&gt; &lt;artifactId&gt;cloud2&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/parent&gt;&lt;artifactId&gt;server&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;name&gt;server&lt;/name&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;!-- 注意这是 client --&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- client端要加web，否则启动报错 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 修改application.properties配置文件 123456#端口号server.port=8086#名称spring.application.name=server#register注册地址eureka.client.service-url.defaultZone=http://localhost:8085/eureka/ 在启动类上加入@EnableDiscoveryClient注解。 启动项目，刷新localhost:8085页面，如果看到如下图所示，表示注册成功]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>springcloud</tag>
        <tag>eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是springcloud]]></title>
    <url>%2F%E4%BB%80%E4%B9%88%E6%98%AFspringcloud%2F</url>
    <content type="text"><![CDATA[SpringCloud简介 Spring Cloud简介官方定义Spring Cloud为开发人员提供了快速构建分布式系统中一些常见模式的工具（例如配置管理，服务发现，断路器，智能路由，微代理，控制总线）。分布式系统的协调导致了样板模式, 使用Spring Cloud开发人员可以快速地支持实现这些模式的服务和应用程序。他们将在任何分布式环境中运行良好，包括开发人员自己的笔记本电脑，裸机数据中心，以及Cloud Foundry等托管平台。 大白话基于SpringBoot的一套快速搭建分布式微服务的框架，有很多现成的组件可以开箱即用。 与SpringBoot的版本依赖关系 SpringBoot SpringCloud 1.2.x Angel版本 1.3.x Brixton版本 1.4.x Camden版本 1.5.x Dalston版本、Edgware版本 2.0.x Finchley版本、Greenwich版本 使用maven引用包时，一定要注意版本的对应关系，否则会启动报错 成员组件]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot mybatis druid多数据源配置]]></title>
    <url>%2Fspringboot-mybatis-druid%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[多数据源配置 项目结构最近项目用到了多数据源，在此处记录一下具体的配置信息。 目前是两个数据库，paas 和 robot，根据数据库，将项目的包结构分为如下图所示，方便管理及后期维护。 项目配置主配置文件 application.properties1234567891011121314151617181920212223242526272829303132333435#连接池配置spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driverClassName=com.mysql.jdbc.Driver#robot库spring.datasource.robot.url=jdbc:mysql://localhost:3306/robot?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=truespring.datasource.robot.username=rootspring.datasource.robot.password=spring.datasource.robot.initialSize=1spring.datasource.robot.maxActive=20spring.datasource.robot.minIdle=1spring.datasource.robot.maxWait=60000spring.datasource.robot.timeBetweenEvictionRunsMillis=60000spring.datasource.robot.minEvictableIdleTimeMillis=300000spring.datasource.robot.validationQuery=select 1spring.datasource.robot.testWhileIdle=true#pass库spring.datasource.paas.url=jdbc:mysql://localhost:3306/paas?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=truespring.datasource.paas.username=rootspring.datasource.paas.password=spring.datasource.paas.initialSize=1spring.datasource.paas.maxActive=20spring.datasource.paas.minIdle=1spring.datasource.paas.maxWait=60000spring.datasource.paas.timeBetweenEvictionRunsMillis=60000spring.datasource.paas.minEvictableIdleTimeMillis=300000spring.datasource.paas.validationQuery=select 1spring.datasource.paas.testWhileIdle=true#实体类扫描路径mybatis.type-aliases-package=com.huayunworld.parser.flowChart.model.db#mybatis配置文件路径mybatis.config-location=classpath:mybatis-config.xml 数据源robot配置1234567891011121314151617181920212223242526272829303132@Configuration@MapperScan(basePackages = "com.huayunworld.parser.flowChart.dao.robot", sqlSessionFactoryRef = "robotSqlSessionFactory")public class RobotDruidConfig &#123; private static final String MAPPER = "classpath:mapping/robot/*.xml"; @ConfigurationProperties("spring.datasource.robot") @Primary @Bean(name = "robotDataSource") public DruidDataSource robotDataSource() &#123; return new DruidDataSource(); &#125; @Bean(name = "robotTransactionManager") @Primary public DataSourceTransactionManager robotTransactionManager() &#123; return new DataSourceTransactionManager(robotDataSource()); &#125; @Bean(name = "robotSqlSessionFactory") @Primary public SqlSessionFactory masterSqlSessionFactory(@Qualifier("robotDataSource") DataSource dataSource) throws Exception &#123; final SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean(); sessionFactoryBean.setDataSource(dataSource); sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(MAPPER)); return sessionFactoryBean.getObject(); &#125;&#125; 数据源paas配置1234567891011121314151617181920212223242526272829@Configuration@MapperScan(basePackages = "com.huayunworld.parser.flowChart.dao.paas", sqlSessionFactoryRef = "paasSqlSessionFactory")public class PaasDruidConfig &#123; private static final String MAPPER = "classpath:mapping/paas/*.xml"; @ConfigurationProperties("spring.datasource.paas") @Bean(name = "paasDataSource") public DruidDataSource paasDataSource() &#123; return new DruidDataSource(); &#125; @Bean(name = "paasTransactionManager") public DataSourceTransactionManager masterTransactionManager() &#123; return new DataSourceTransactionManager(paasDataSource()); &#125; @Bean(name = "paasSqlSessionFactory") public SqlSessionFactory masterSqlSessionFactory(@Qualifier("paasDataSource") DataSource dataSource) throws Exception &#123; final SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean(); sessionFactoryBean.setDataSource(dataSource); sessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(MAPPER)); return sessionFactoryBean.getObject(); &#125;&#125; 测试使用时，与之前的mybatis的使用方法一样，直接注入dao层对象即可。spring会根据不同包下的dao，连接不同的数据库。 测试代码： 12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTest(classes = RbcParserApplication.class)@Transactionalpublic class RbcParserApplicationTests &#123; // robot库 @Resource private AttrMapper attrMapper; // paas库 @Resource private CallRecBotMapper callRecBotMapper; /** * 两个数据库同时测试 查询 */ @Test public void allDataSourceSelectTest() &#123; System.out.println(attrMapper.selectAllData()); System.out.println(callRecBotMapper.selectAllData()); &#125; 输出结果： 通过测试可以看出，两个库分别连接成功了。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
        <tag>多数据源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板方法模式及其应用场景 动机&emsp;&emsp;在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。 &emsp;&emsp;如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？ 模板方法模式模板方法模式的功能&emsp;&emsp;模板方法模式的功能在于固定算法骨架，而让具体算法实现可扩展。 &emsp;&emsp;这在实际应用中非常广泛，尤其是在设计框架级功能的时候非常有用。框架定义了算法的实现步骤，在合适的地点让开发人员进行扩展，实现具体的算法。比如在DAO层设计通用的增删改查功能。 &emsp;&emsp;模板方法设计模式还额外提供了一个好处，就是可以控制子类的扩展。因为在父类中定义好了算法的步骤，只是在某几个固定的点才回调用到被子类实现的方法，因此也就只允许在这几个点来扩展功能。这些可以被子类覆盖以扩展功能的方法通常被称为“钩子”方法，比如servlet中的生命周期函数，spring中的拦截器等。 代码演示要点总结&emsp;&emsp;模板方法模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。 &emsp;&emsp;除了可以灵活应对自步骤的变化外，“不要调用我，让我调用你”的反向控制结构是模板方法模式的典型应用。 &emsp;&emsp;在具体实现方面，被模板方法调用的虚方法可以具体实现，也可以没有任何实现，但一般都把它们设置为protected方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot时间格式化]]></title>
    <url>%2Fspringboot%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最近使用了JDK8中新的时间API LocalDateTime，这里记录一下与springboot集成时出现的一些需要注意的细节 1.问题的出现在未使用LocalDateTime以前，项目中的实体类都是用Timestamp对应的。可以在springboot的主配置文件中，统一进行格式化设置 12# 返回时间戳spring.jackson.serialization.write-dates-as-timestamps=true 使用@responseBody返回json数据时，会自动将时间格式化为毫秒值。 但当使用了LocalDateTime后，这种做法就失效了，时间数据会被转成一个类似于[2019,2,22,15,24,55]的数组，而并非毫秒值。引用自jackson-modules-java8 LocalDate, LocalTime, LocalDateTime, and OffsetTime, which cannot portably be converted to timestamps and are instead represented as arrays when WRITE_DATES_AS_TIMESTAMPS is enabled. 2.解决方案 自定义JsonSerialize 123456789101112/** * json序列化，将LocateDateTime转换为时间戳 * * @author zhangxu */public class LocalDateTimeConverter extends JsonSerializer&lt;LocalDateTime&gt; &#123; @Override public void serialize(LocalDateTime value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123; gen.writeNumber(value.toInstant(ZoneOffset.of("+8")).toEpochMilli()); &#125;&#125; 在实体类时间属性上，加入@JsonSerialize(using = LocalDateTimeConverter.class)注解即可 3.其他问题服务器返回时间戳的问题解决了，但还会有另一个问题，就是时间戳的接收问题。当接口使用实体类接收数据时，无法解析客户端传过来的时间戳，会报类型转换错误的bug。 这就需要自定义Converter解决问题。 1234567891011121314/** * spring接收参数格式转化 long --&gt; LocalDateTime * * @author zhangxu */@Configurationpublic class DateConfig implements Converter&lt;String, LocalDateTime&gt; &#123; @Override public LocalDateTime convert(String source) &#123; ZoneOffset zoneOffset = ZoneOffset.of("+8"); return LocalDateTime.ofInstant(Instant.ofEpochMilli(Long.parseLong(source)), zoneOffset); &#125;&#125; 再次启动项目，就可以自动将时间戳转换为 LocalDateTime了。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat更新maven索引]]></title>
    <url>%2Ftomcat%E6%9B%B4%E6%96%B0maven%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[本文介绍了使用tomcat手动更新idea的maven索引 因为某些原因，使用idea更新maven索引时，非常非常慢，所以我们需要手动进行更新。 首先去http://repo1.maven.org/maven2/.index/下，下载两个文件 nexus-maven-repository-index.properties nexus-maven-repository-index.gz 在本地tomcat的webapps下，创建maven2\.index文件夹，.index文件夹在windows下，需要使用命令创建 1mkdir .index 将下载好的文件，放入创建好的目录下，启动tomcat 在idea中，设置maven代理。 -DproxyHost设置代理IP -DproxyPort设置代理端口，这里设置为本地tomcat端口 现在就可以快速更新maven索引了。]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solr7.2 tomcat8环境搭建]]></title>
    <url>%2Fsolr7-2-tomcat8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[solr7.2和tomcat8具体搭建流程 配置前的准备下载jdk1.8，并安装配置好环境变量，下载路径：JDK1.8 下载solr7.2，解压待用。下载路径：solr 下载tomcat8，解压待用。下载路径：tomcat8 开始配置配置tomcat 打开tomcat的webapps路径，创建一个文件夹，命名为solr。 打开解压后的solr文件夹，将solr-7.2.0\server\solr-webapp\webapp下，所有的文件，拷入上一步在tomcat中创建的solr文件夹下。 将solr-7.2.0\server\lib\ext下所有包，solr-7.2.0\server\lib下除了jetty开头的所有包，拷入tomcat-8.5.31\webapps\solr\WEB-INF\lib中。 将solr-7.2.0\dist下的两个以solr-dataimporthandler开头的包拷入tomcat-8.5.31\webapps\solr\WEB-INF\lib中 在tomcat-8.5.31\webapps\solr\WEB-INF新建classes目录，然后把solr-7.2.0\server\resources\log4j.properties粘贴过去 把solr-7.2.0\server\solr整个文件夹复制到tomcat根路径下，并重命名为solr-home，这个是solr的核心配置文件夹。 将solr-7.2.0下的contrib和dist拷入solr-home中。 修改tomcat-8.5.31\webapps\solr\WEB-INF\web.xml文件，指定solr-home位置 注释权限控制 运行tomcat，在浏览器输入http://localhost:8080/solr/index.html，即可访问solr。]]></content>
      <categories>
        <category>solr</category>
      </categories>
      <tags>
        <tag>solr</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java使用freemarker生成复杂word表格]]></title>
    <url>%2Fjava%E4%BD%BF%E7%94%A8freemarker%E7%94%9F%E6%88%90%E5%A4%8D%E6%9D%82word%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[本文介绍了使用freemarker生成复杂word表格的具体操作流程 制作模板创建空word文档，制作表格样式 填入自定义代码 注意:如果有图片,需要先插入图片进行占位,否则会导致插入图片失败. 另存为.xml文件 编辑xml文件使用文本编辑器打开上一步保存的.xml文件,将自定义代码修改为${xxx}的样式. 注意,有时候会有如下情况: 手动修复后: 图片部分,在xml文件里是一大串base64字符串,直接删除后,手动填入${xxx}(此处为自定义代码)即可. 写入模板在poi.xml中贴入如下坐标,引入freemarker 12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt; 如果不是Maven项目,请自行下载jar包,导入项目即可. 实现代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Testpublic void test1() throws IOException, TemplateException &#123; // 配置freemarker模板 Configuration cfg = new Configuration(Configuration.VERSION_2_3_22); // 模板文件所在目录 cfg.setClassForTemplateLoading(ReadWord2.class, "/"); // 设置编码格式 cfg.setDefaultEncoding("UTF-8"); // 具体模板名称 Template temp = cfg.getTemplate("人员实名登记表.xml"); Map&lt;String, Object&gt; data = new HashMap&lt;&gt;(); String img = "E:\\资料\\壁纸\\1502468435367.jpg"; FileInputStream fis = new FileInputStream(img); data.put("LB", ""); data.put("XM", "张三"); data.put("IDCARD", "111111111111"); data.put("IMG", ImageUtils.fileToBase64(fis)); data.put("OFFICE", "中国航天集团"); data.put("OFPHONE", "147258369"); data.put("ADDRESS", "常住地址"); data.put("PHONE", "12345678910"); data.put("IMEI", "sfsdfdsfds"); data.put("MAC", "ac:bc:cd:12:18"); data.put("TYPE", "小米"); data.put("EMAIL", "123456@qq.com"); data.put("WEIBO", "123@sina.com"); data.put("QQ", "123456"); data.put("WECHAT", "13123123"); data.put("OTHER", "xxx"); data.put("GX1", "父亲"); data.put("XM1", "大明"); data.put("IDCARD1", "156431561136566846"); data.put("PHONE1", "12345678910"); data.put("JOB1", "iOS工程师"); data.put("GX2", "母亲"); data.put("XM2", "大明老婆"); data.put("IDCARD2", "sdfdsd"); data.put("PHONE2", "12345678910"); data.put("JOB2", "Android工程师"); data.put("GX3", "妹妹"); data.put("XM3", "小明妹妹"); data.put("IDCARD3", "犯得上发射点"); data.put("PHONE3", "12345678910"); data.put("JOB3", "iOS工程师"); data.put("NUM1", "晋A·123456"); data.put("MODEL1", "马自达"); data.put("COLOR1", "红色"); data.put("NUM2", "晋A·654321"); data.put("MODEL2", "路虎"); data.put("COLOR2", "黑色"); data.put("NUM3", "晋A·147258"); data.put("MODEL3", "丰田"); data.put("COLOR3", "白色"); String fileName = "name.doc"; OutputStream fos = new FileOutputStream(new File(fileName)); Writer out = new OutputStreamWriter(fos, "utf-8"); temp.process(data, out); // 关闭流 fos.flush(); fos.close();&#125; 文件生成base64字符串的代码: 1234567891011121314151617181920212223242526272829public static String fileToBase64(InputStream is) &#123; String str = null; try &#123; //将InputStream转换为byte数组 ByteArrayOutputStream byteArray = new ByteArrayOutputStream(); byte[] bytes = new byte[1024]; //存放循环读取的临时变量 int i = 0; while ((i = is.read(bytes)) &gt; 0) &#123; byteArray.write(bytes, 0, i); &#125; //将读取的字节转换为base64格式的字符串 str = new String(Base64.encodeBase64(byteArray.toByteArray())); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; finally &#123; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return str; &#125; 注意:如果部分参数没有值,请填写为空字符串,否则会报错. 生成的word如下:]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Redis完成定时任务]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Redis%E5%AE%8C%E6%88%90%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[使用Redis中的Expire key，结合springboot实现定时任务通知。 场景&emsp;&emsp;使用Java做过项目的人大概都用过定时器。一般来说，项目里订单模块和评论模块，都会涉及到定时任务执行。比如说： 用户下订单后，需要在5分钟内完成支付，否则订单关闭； 用户在完成订单后，如果没有评论，过一星期，系统自动评论，并完结。 我以前曾经做过一个租车系统，其中订单的预约逻辑是这样的： 用户选择车辆并预约 后台系统开始计时 计时结束后，如果用户没有进行支付，则取消本次订单 当时后台计时部分的技术，用的就是java中的定时器类Timer ,使用schedule来设置定时任务。虽然说功能实现了，但还是有很多问题，因为Timer本质上还是启动了一个线程来进行处理。当预约用户过多时，系统内存就会飙升，而且当发布新功能时，如果重启服务器，所有的定时器都会丢失。 解决思路薛定谔解决法&emsp;&emsp;在订单信息中，加入过期时间，当用户查询订单或其他操作时，检查一下有没有过期的预订单，如果有，则进入逻辑处理。也就是说，当用户不进行操作时，这个预订单是不会自己结束的。这样做的好处在于，当系统重启时，这个订单的状态是不会收到影响的。坏处当然也显而易见，延迟率太高，主动权完全决定在用户手中。 轮询法&emsp;&emsp;同样的，在订单信息中加入过期时间，后台启动一个定时线程，每隔一段时间遍历一次订单信息，如果有到期的，则结束订单。这种方法同样会影响系统性能。 使用Redis定时器解决Redis定时器&emsp;&emsp;Redis中有一个expire命令，用来设置key的过期时间。使用发布订阅，可以接收到key的过期提醒，当key过期时，再执行取消订单的逻辑，就可以了。 redis 定时器演示 1234127.0.0.1:6379&gt; set test tom EX 10OK127.0.0.1:6379&gt; get test(nil) 设置test(key)的过期时间为10秒，10秒过后key自动销毁。 当然，仅仅有定时器还是不够的，接下来看redis的另一个功能，发布订阅。 Redis发布订阅Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 Redis 客户端可以订阅任意数量的频道。 用一张图来展示频道(channel1)与订阅者(client2, client5, client1)的关系： 当有消息发布时，他们的关系： 消息经由频道广播到每个订阅者中。 发布订阅演示： 首先创建一个频道： 12345127.0.0.1:6379&gt; SUBSCRIBE chat1Reading messages... (press Ctrl-C to quit)1) "subscribe"2) "chat1"3) (integer) 1 此时控制台进入阻塞状态。 开启2个控制台，分别订阅chat1频道 12345127.0.0.1:6379&gt; PSUBSCRIBE chat1Reading messages... (press Ctrl-C to quit)1) "psubscribe"2) "chat1"3) (integer) 1 这两个控制台也依次进入阻塞状态。 再开一个控制台，进行信息的发布： 123127.0.0.1:6379&gt; PUBLISH chat1 "hello everyone!"(integer) 3127.0.0.1:6379&gt; 此时两个订阅者和一个频道创建者都分别收到了相同的内容 hello everyone! 这里放上一张图片，效果可能会比较好： 发消息之前 发消息之后 redis的key过期通知也是基于发布订阅模型的。不同的是订阅频道是固定的__keyevent@0__:expired,当然，redis还有好多类似与这种特定频道的通知，想了解更多，可以看这里Redis键空间通知。 Redis过期通知要使用Redis的过期通知功能，需要首先开启该功能。 在配置文件中加入如下语句： 1notify-keyspace-events Ex 控制台1订阅频道__keyevent@0__:expired 12345127.0.0.1:6379&gt; PSUBSCRIBE __keyevent@0__:expiredReading messages... (press Ctrl-C to quit) 1) "psubscribe" 2) "__keyevent@0__:expired" 3) (integer) 1 控制台2存入一个key，并设置过期时间 12127.0.0.1:6379&gt; set test tom EX 10OK 当10秒过后，控制台1收到信息 12341) "pmessage"2) "__keyevent@0__:expired"3) "__keyevent@0__:expired"4) "test" 使用springboot接收Redis过期通知首先在maven中配置redis1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 这个包是spring实现的redis client功能的包。 在springboot配置文件中配置redis12345678910111213141516171819#Redis配置#数据库索引，默认为0spring.redis.database=0#服务器地址，默认localhostspring.redis.host=localhost#端口，默认6379spring.redis.port=6379#密码，默认为空spring.redis.password=#连接池最大连接数，默认为8spring.redis.jedis.pool.max-active=8#连接池最大阻塞等待时间，使用负值表示没有限制spring.redis.jedis.pool.max-wait=-1#连接池最大空闲连接，默认为8spring.redis.jedis.pool.max-idle=8#连接池中的最小空闲连接，默认为0spring.redis.jedis.pool.min-idle=0#连接超时时间(毫秒)spring.redis.timeout=10 代码实现首先写接收通知的处理方法 12345678910111213@Componentpublic class RedisMessageReceiver &#123; /** * 接收redis消息，并处理 * * @param message 过期的redis key */ public void receiveMessage(String message) &#123; System.out.println("通知的key是：" + message); &#125;&#125; 再写频道订阅的代码： 1234567891011121314151617181920212223242526272829303132333435@Configurationpublic class RedisConfig &#123; /** * redis 订阅频道 * * @param connectionFactory * @param listenerAdapter * @return */ @Bean RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory, MessageListenerAdapter listenerAdapter) &#123; RedisMessageListenerContainer container = new RedisMessageListenerContainer(); container.setConnectionFactory(connectionFactory); // 订阅通道，key过期时通知 container.addMessageListener(listenerAdapter, new PatternTopic("__keyevent@0__:expired")); // 可以订阅多个通道 return container; &#125; /** * 配置redis事件监听处理器 * * @param receiver * @return */ @Bean MessageListenerAdapter listenerAdapter(RedisMessageReceiver receiver) &#123; return new MessageListenerAdapter(receiver, "receiveMessage"); &#125;&#125; 这样整个代码就完成了。我们来测试一下效果： 使用控制台，新增一个key，并设置过期时间为10秒 123127.0.0.1:6379&gt; set testnofity xxx EX 10OK127.0.0.1:6379&gt; 切换到我们的程序中，可以在控制台看到如下信息： 好了，现在我们就可以根据不同的key做不同的业务逻辑处理了。比如规定，所有订单的key，都必须以order-订单号的形式存入，这样，当接收到订单过期的通知时，就可以解析出订单信息，进一步处理了。 当然，这个只是一种解决思路，你也可以使用一些其他的方式实现，比如说使用RabbitMQ消息队列实现。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux配置springboot开机自启]]></title>
    <url>%2FLinux%E9%85%8D%E7%BD%AEspringboot%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%2F</url>
    <content type="text"><![CDATA[本文介绍了Linux环境下，自定义服务的开机自启 背景&emsp;&emsp;对于不使用云服务器的公司而言，服务器断电是一件很头痛的事。最近公司的一个外包项目上线了，但甲方三天两头打电话，说服务没办法访问。最后才找出原因，他们的服务器断过电。一开始，我以为是偶发事件，结果是他们的服务器经常性的断电。每次断电重启后，都要打电话给我，重新启动项目，非常麻烦。能不能配置一下服务器，在开机的时候就启动指定的服务呢？ 配置Linux服务开机自启，有三种方式。 编辑/etc/rc.local使用vi编辑此文件，直接添加要执行的命令就行 12345678910111213141516#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.touch /var/lock/subsys/local# 这里是自定义的执行命令nohup /usr/java/jdk1.8.0_162/bin/java -jar /data/wwwroot/api/speed-api-0.0.1-SNAPSHOT.jar &amp;&gt;/dev/null 这里有一点需要注意，即使配置过环境变量，在这里也要指定java命令的路径，否则会有如下错误。 12nohup: ignoring inputnohup: failed to run command `java': No such file or directory 因为在加载执行此文件的时候，环境变量还未生效。 写脚本，放入/etc/profile.d自己写一个shell脚本，放在此路径下，系统启动时会自动执行。 123456[root@localhost ~]# cd /etc/profile.d/[root@localhost profile.d]# vi mystart.sh#!/bin/bashnohup /usr/local/java/jdk1.8.0_162/bin/java -jar /data/wwwroot/api/speed-api-0.0.1-SNAPSHOT.jar &amp;&gt;/dev/null 此处同上，依然使用完全限定的java命令来执行。编写完脚本后，要为脚本分配可执行权限。 1[root@localhost profile.d]# chmod a+x mystart.sh 使用chkconfig命令执行自己写脚本，放入/etc/init.d下 12345678[root@localhost ~]# cd /etc/init.d[root@localhost init.d]# vi speed-start#!/bin/bash# chkconfig: - 95 15# description: speed-api start scriptnohup /usr/local/java/jdk1.8.0_162/bin/java -jar /data/wwwroot/api/speed-api-0.0.1-SNAPSHOT.jar &amp;&gt;/data/wwwroot/api/mylog.log 保存脚本，并赋予执行权限 1[root@localhost init.d]# chmod a+x speed-start 添加到chkconfig中，并设置开机启动 12[root@localhost init.d]# chkconfig --add speed-start[root@localhost init.d]# chkconfig speed-start on 这样，当下次服务器重启时，项目就可以自己启动了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的中断机制]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[调用Thread.stop()该方法强迫停止一个线程，并抛出一个新创建的ThreadDeath对象作为异常。然而，Thread.stop()不安全，已不建议使用。 使用Thread.interrupt()&emsp;&emsp;Java中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。 &emsp;&emsp;Java中断模型也可以简单做如下理解，每个线程对象里都有一个boolean类型的标识，代表着是否有中断请求(该请求可以来自所有线程，包括被中断的线程本身)。例如：当线程t1想中断线程t2，只需要在线程t1中将线程t2对象的中断标识置为true，然后线程t2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像没有被中断一样。 Thread类中关于中断的方法： public boolean isInterrupted()：测试线程是否已经中断。 public void interrupt()：中断线程。 1234567891011121314151617181920212223public class ThreadTest2 &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; boolean stop = true; while (stop) &#123; System.out.println("thread is running..."); long time = System.currentTimeMillis(); // 延时1s while (System.currentTimeMillis() - time &lt; 1000) &#123; &#125; &#125; &#125;; Thread thread = new Thread(runnable, "test Thread"); System.out.println("启动线程"); thread.start(); Thread.sleep(3000); thread.interrupt(); // 中断线程 System.out.println("线程是否中断：" + thread.isInterrupted()); &#125;&#125; 输出结果如下： 12345678910启动线程thread is running...thread is running...thread is running...thread is running...线程是否中断：truethread is running...thread is running...thread is running......... 从运行结果上看，线程并没有结束，因为线程2并没有处理该中断请求。接下来，我们对例子稍加改进： 1234567891011121314151617181920212223242526272829public class ThreadTest2 &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; boolean stop = true; while (stop) &#123; System.out.println("thread is running..."); long time = System.currentTimeMillis(); // 延时1s while (System.currentTimeMillis() - time &lt; 1000) &#123; &#125; // 注意这里 ==================== if (Thread.currentThread().isInterrupted()) &#123; System.out.println("线程中断后退出"); break; &#125; // 注意这里 ==================== &#125; &#125;; Thread thread = new Thread(runnable, "test Thread"); System.out.println("启动线程"); thread.start(); Thread.sleep(3000); thread.interrupt(); // 中断线程 System.out.println("线程是否中断：" + thread.isInterrupted()); &#125;&#125; 输出结果如下： 1234567启动线程thread is running...thread is running...thread is running...thread is running...线程是否中断：true线程中断后退出 此时线程2才真正终止结束了。 注意&emsp;&emsp;如果线程处在可中断状态下（调用了Thread.wait()或者Thread.sleep()等特定会发生阻塞的api），那么该线程会被立即唤醒，同时抛出一个InterruptedException。简单的异常处理如下： 1234567891011Runnable runnable = () -&gt; &#123; boolean stop = true; while (stop) &#123; System.out.println("thread is running..."); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; break; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建线程的三种方法]]></title>
    <url>%2F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java中创建线程的三种写法 继承Thread类，重写run()方法1234567891011public class ThreadTest1 extends Thread &#123; @Override public void run() &#123; System.out.println("线程启动了"); &#125; public static void main(String[] args) &#123; ThreadTest1 threadTest1 = new ThreadTest1(); threadTest1.start(); // 启动线程 &#125;&#125; 这种实现方式的缺点是一个类只能继承一个父类，类的可扩展性差。 实现Runnable接口，重写run()方法123456789101112public class ThreadTest2 implements Runnable &#123; @Override public void run() &#123; System.out.println("线程启动了"); &#125; public static void main(String[] args) &#123; Thread thread = new Thread(new ThreadTest2()); thread.start(); // 启动线程 &#125;&#125; 这种写法就比第一种的扩展性要好。毕竟Java是可以多实现的。 当然，也可以使用匿名内部类的方式进行简写，写法如下： 123456789101112public class ThreadTest3 &#123; public static void main(String[] args) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; System.out.println("线程启动了"); &#125; &#125;; thread.start(); &#125;&#125; 如果你用的JDK的版本是8以上的，还可以使用lambda表达式再次进行简写： 1234567public class ThreadTest4 &#123; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; System.out.println("线程启动了"); &#125;).start(); &#125;&#125; 实现Callable接口，重写call()方法1234567891011121314public class ThreadTest5 implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println("启动线程"); return "thread"; &#125; public static void main(String[] args) &#123; FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new ThreadTest5()); Thread thread = new Thread(task); thread.start(); &#125;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下MySQL5.7的安装配置]]></title>
    <url>%2Fwindows%E4%B8%8BMySQL5-7%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了在windows环境下的MySQL5.7的安装配置 下载点击这里进入官网下载。 根据自己的需求，选择对应的版本下载即可。 解压配置基本配置下载好的包，解压后是没有exe执行文件的，需要我们使用命令行进行配置安装。 将解压后的文件放入到自己习惯的软件安装路径，我放到了D:\soft下，并将文件夹重命名为mysql。 进入D:\soft\mysql下，新建一个空的文件，并重命名为my.ini。 使用文本编辑器打开my.ini文件，将以下内容复制进去，并保存。 12345678910111213141516[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]#设置3306端口port = 3306 # 设置mysql的安装目录basedir=D:/soft/mysql# 设置mysql数据库的数据的存放目录datadir=D:/soft/mysql/data# 允许最大连接数max_connections=500# 服务端字符编码character-set-server=utf8# 默认存储引擎default-storage-engine=INNODB 环境变量桌面我的电脑 右键–&gt;属性–&gt;高级系统设置–&gt;环境变量，打开环境变量编辑界面。 在系统变量里，找到Path变量，双击进入编辑界面。 点击确定即可。 安装MySQL安装服务以管理员身份，运行cmd，进入MySQL文件夹路径。 12345C:\WINDOWS\system32&gt;cd D:soft\mysqlC:\WINDOWS\system32&gt;D:D:\soft\mysql&gt; 执行安装命令，安装MySQL服务。 1234D:\soft\mysql&gt;mysqld installService successfully installed.D:\soft\mysql&gt; 如果输出Service successfully installed.，表示MySQL服务安装成功。 初始化数据库123D:\soft\mysql&gt;mysqld initializeD:\soft\mysql&gt; 初始化完毕后，会自动生成一个文件夹，这个文件夹位于 my.ini配置项中datadir=指定的位置。 配置root账户数据库初始化后，root账户的密码是随机的，无法登录。我们需要重新设置root账户密码。 1D:\soft\mysql&gt;mysqld --skip-grant-tables 输入以上命令，会开启免密登录的MySQL服务，此时命令行处于暂停状态无法使用。 新打开一个命令行，执行mysql -u root，就可以连接上MySQL了。 1234567891011121314C:\WINDOWS\system32&gt;mysql -u rootWelcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; 执行flush privileges;刷新权限。 执行grant all privileges on *.* to &#39;root&#39;@&#39;localhost&#39; identified by &#39;自定义密码&#39; with grant option;修改密码 再次执行flush privileges;生效修改。 输入exit退出MySQL。 1234567891011121314151617181920212223C:\WINDOWS\system32&gt;mysql -u rootWelcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec)mysql&gt; grant all privileges on *.* to 'root'@'localhost' identified by 'xxx' with grant option;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; exit 打开任务管理器，找到MySQL的进程，结束掉。 再次打开cmd，输入命令启动MySQL，就可以正常使用了。 1234567891011121314151617181920C:\WINDOWS\system32&gt;net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。C:\WINDOWS\system32&gt;mysql -u root -pEnter password: *******Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nginx和tomcat配置负载均衡]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8nginx%E5%92%8Ctomcat%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[本文介绍了使用nginx和tomcat配置简单的负载均衡 背景做开发的常常会遇到这样一个问题：项目上线了，而后续又需要添加新功能，常常是把服务停掉，将新功能部署到服务器上，再重启服务器。这样会导致服务一段时间不可用，能不能不停服务器把新功能更新呢？ 说明我们可以使用nginx和多个tomcat实现这样的效果，当需要部署新功能时，可以先停掉一个tomcat进行部署，此时如果有客户端进行请求，nginx会自动将请求转发到运行的tomcat中。等部署完成后再启动，nginx检测到服务可用时，就会自动将请求转发到正常运行的tomcat中。这样就完成了不停机更新。 准备安装Nginxnginx安装方式有好多种，我这里偷个懒，使用oneinstack一键安装脚本进行安装。如果你对这个感兴趣，可以到这里去看看。安装过程很简单，执行脚本后，就可以自动安装上。 安装tomcattomcat是不用进行安装的，直接解压就可以使用，可以从tomcat官网获取需要的版本。在Linux下使用wget下载。 123wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz# 解压tar -zxvf apache-tomcat-8.5.32.tar.gz 将tomcat复制两份，我放到/usr/local下，这个位置大家可以随意放置 12cp -r apache-tomcat-8.5.32 /usr/local/tomcat1cp -r apache-tomcat-8.5.32 /usr/local/tomcat2 修改tomcat2的端口号，否则无法启动两个tomcat。将conf/service.xml中的 8005 8080 8009 分别修改成其他的端口号，比如 8006 8081 8010。 为了方便看效果，修改tomcat中的webapps/ROOT/index.jsp，在其中加入如下代码 1&lt;h1&gt;tomcat1&lt;/h1&gt; tomcat2类似。这样tomcat就配置好了。分别启动两个tomcat进行访问测试。 如果浏览器无法访问，请检查防火墙是否阻止了端口。 Nginx配置编辑nginx的配置文件nginx.conf，在http{}中加入如下配置： 1234upstream test &#123; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; 在server{}中加入如下配置： 12345location / &#123; root html; index index.html index.htm index.jsp; proxy_pass http://test;&#125; 然后重启nginx 1/usr/local/nginx/sbin/nginx -s reload 此时再次访问的时候，就可以看到效果了。多次刷新页面，可以看到tomcat1和tomcat2互相切换，这样简单的负载均衡就配置好了。 负载均衡策略轮询默认的配置，请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器宕掉，能自动剔除。 1234upstream test &#123; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; 最少连接请求会转发到连接最少的服务器上处理 12345upstream test &#123; least_conn; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; weight 权重指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况，weight默认是1。 12345upstream test &#123; # 服务器A和服务器B的访问比例为：2-1;比如有3个请求，前两个会访问A，三个访问B，其它规则和轮询一样 server 127.0.0.1:8080 weight=2; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; ip_hash每个请求按访问ip的hash值分配，这样同一客户端连续的Web请求都会被分发到同一服务器进行处理，可以解决session的问题。 12345upstream test &#123; ip_hash; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; url_hash（第三方）url_hash是nginx的第三方模块，nginx本身不支持，需要打补丁。 nginx按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器、文件服务器、静态服务器时比较有效。缺点是当后端服务器宕机的时候，url_hash不会自动跳转的其他缓存服务器，而是返回给用户一个503错误。 12345upstream nginxDemo &#123; hash $request_url; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream nginxDemo &#123; fair; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>tomcat</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己搭建Shadowsocks服务器]]></title>
    <url>%2F%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BAShadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了在Linux环境下搭建Shadowsocks服务器的方法 前言首先必须要有一个国外的服务器(废话)，我这里使用亚马逊的服务器为例，系统版本是redhat7.5。 安装过程使用Shadowsocks 一键安装脚本（四合一）脚本工具进行安装。 使用root账户，执行如下命令： 123[root@tom ~]# wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh[root@tom ~]# chmod +x shadowsocks-all.sh[root@tom ~]# ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 注意：如果没有wget 工具，需要安装一下： 1yum install -y wget 如果不出意外的话，会自动执行交互式安装程序。最终安装成功后会输出如下信息： 12345678910111213Congratulations, your_shadowsocks_version install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_methodYour QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients) ss://your_encryption_method:your_password@your_server_ip:your_server_portYour QR Code has been saved as a PNG file path: your_path.pngWelcome to visit:https://teddysun.com/486.htmlEnjoy it! 服务器安装好后，就可以在客户端配置使用了，这里放上客户端的下载链接。 常规版 Windows 客户端https://github.com/shadowsocks/shadowsocks-windows/releases ShadowsocksR 版 Windows 客户端https://github.com/shadowsocksrr/shadowsocksr-csharp/releases 遇到的问题我在安装过程中，遇到了两个包依赖问题导致安装失败，这两个包分别是epel和qrencode，最后通过手动安装解决了依赖问题。具体的命令如下： 1234# 下载epel依赖包wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# 安装依赖yum install epel-release-latest-7.noarch.rpm qrencode包的下载地址：下载地址 我这里选择Centos 7 的包进行下载，大家可以根据自己的系统选择对应的包进行下载。 1234# 下载依赖wget http://mirror.centos.org/centos/7/os/x86_64/Packages/qrencode-3.4.1-3.el7.x86_64.rpm# 安装yum install qrencode-3.4.1-3.el7.x86_64.rpm 依赖安装好以后，再次执行Shadowsocks的安装脚本，就可以完成安装了。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用xx-net实现科学上网]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8xx-net%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[本文介绍了使用xx-net科学上网的详细流程 下载点击xx-net进入下载页面 下载完成后，本地解压，根据官网的教程操作即可。 文档地址 遇到的问题无法开启IPv6。其实这个不用根据官网的开启方法开启，下载好的包里就有开启脚本。具体的路径如下： XX-Net-3.12.2\code\default\gae_proxy\local\ipv6_tunnel\disable_ipv6.bat XX-Net-3.12.2\code\default\gae_proxy\local\ipv6_tunnel\enable_ipv6.bat 直接双击执行这两个脚本就可以了。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot自定义json格式转换]]></title>
    <url>%2Fspringboot%E8%87%AA%E5%AE%9A%E4%B9%89json%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[最近在看JDK8的新功能，在项目中使用了新的时间API，结果却引发了一个问题，本篇文章详细介绍了问题的出现以及解决方法。 错误的出现web项目中，我们常常会定义实体类，来对应数据库的表。 12345678910public class User implements Serializable &#123; private Integer id; private String name; private String password; private Instant created;&#125; 在上面的实体类中，我使用了JDK8中新的API java.time.Instant来替代java.util.Date类。经过测试后，可以使用mybatis正常操作数据库。但当写接口返回json时，created字段原本应该返回时间戳，但却返回成了浮点数。 1"created":1522234791.000000000 解决办法Instant中是由toEpochMilli()方法转为时间戳的，我们可以自定义一个JsonSerializer来进行转换。 1234567public class InstantConverter extends JsonSerializer&lt;Instant&gt; &#123; @Override public void serialize(Instant value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123; gen.writeNumber(value.toEpochMilli()); &#125;&#125; 定义完成后，需要在指定的属性上加@JsonSerialize(using = 自定义转换方法.class)，来标注。这样当返回json数据时，会自动调用我们的方法进行格式转换。 修改后的实体类 1234567891011public class User implements Serializable &#123; private Integer id; private String name; private String password; @JsonSerialize(using = InstantConverter.class) private Instant created;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot将项目与依赖分开打包]]></title>
    <url>%2Fspringboot%E5%B0%86%E9%A1%B9%E7%9B%AE%E4%B8%8E%E4%BE%9D%E8%B5%96%E5%88%86%E5%BC%80%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文介绍了在spring boot项目中，配置项目与依赖分开打包的方法 写在前面的&emsp;&emsp;当我们使用spring boot写项目时，一般都会遇到一个问题，那就是spring boot打包时，会将自己写的代码和项目的所有依赖文件打成一个可执行的jar包。通常我们的项目都是运行在服务器上的，当项目更新时，每次都要向服务器上传这个包。如果项目的依赖包很多，那么这个文件就会非常大。大文件上传不仅浪费带宽，有时候网络不稳定，传输一半断网，又要重新上传，非常麻烦。 默认的maven配置 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; &emsp;&emsp;如果能将项目外部依赖和自己的代码包分开打包，当修改项目后，只需要再次覆盖修改后的包，那岂不是美滋滋？ 解决方案使用maven的assembly打包插件 assembly配置&emsp;&emsp;在项目中创建一个文件，我放在src/main/assembly/assembly.xml中，大家可以根据喜好自己创建。 assembly中的具体配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd"&gt; &lt;!-- 必须写，否则打包时会有 assembly ID must be present and non-empty 错误 这个名字最终会追加到打包的名字的末尾，如项目的名字为 speed-api-0.0.1-SNAPSHOT, 则最终生成的包名为 speed-api-0.0.1-SNAPSHOT-bin.zip --&gt; &lt;id&gt;bin&lt;/id&gt; &lt;!-- 打包后的文件格式,可以是zip,tar,tar.gz,tar.bz2,jar,war,dir --&gt; &lt;formats&gt; &lt;format&gt;zip&lt;/format&gt; &lt;/formats&gt; &lt;!-- 压缩包下是否生成和项目名相同的根目录 --&gt; &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt; &lt;dependencySets&gt; &lt;dependencySet&gt; &lt;!-- 不使用项目的artifact，第三方jar不要解压，打包进zip文件的lib目录 --&gt; &lt;useProjectArtifact&gt;false&lt;/useProjectArtifact&gt; &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt; &lt;unpack&gt;false&lt;/unpack&gt; &lt;/dependencySet&gt; &lt;/dependencySets&gt; &lt;fileSets&gt; &lt;!-- 把项目相关的说明文件，打包进zip文件的根目录 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;project.basedir&#125;&lt;/directory&gt; &lt;outputDirectory&gt;&lt;/outputDirectory&gt; &lt;includes&gt; &lt;include&gt;README*&lt;/include&gt; &lt;include&gt;LICENSE*&lt;/include&gt; &lt;include&gt;NOTICE*&lt;/include&gt; &lt;/includes&gt; &lt;/fileSet&gt; &lt;!-- 把项目的配置文件，打包进zip文件的config目录 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;outputDirectory&gt;config&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;!-- 把项目的脚本文件，打包进zip文件的bin目录 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/bin&lt;/directory&gt; &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;!-- 把项目自己编译出来的jar文件，打包进zip文件的根目录 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;outputDirectory&gt;&lt;/outputDirectory&gt; &lt;includes&gt; &lt;include&gt;*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/fileSet&gt; &lt;/fileSets&gt;&lt;/assembly&gt; maven中的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;build&gt; &lt;plugins&gt; &lt;!-- 指定启动类，将依赖打成外部jar包 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;!-- 生成的jar中，不要包含pom.xml和pom.properties这两个文件 --&gt; &lt;addMavenDescriptor&gt;false&lt;/addMavenDescriptor&gt; &lt;manifest&gt; &lt;!-- 是否要把第三方jar放到manifest的classpath中 --&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;!-- 外部依赖jar包的最终位置 --&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;!-- 项目启动类 --&gt; &lt;mainClass&gt;com.zbrx.speed.App&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 使用assembly打包 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;descriptors&gt; &lt;!-- assembly配置文件位置 --&gt; &lt;descriptor&gt;src/main/assembly/assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- 打包发布时，跳过单元测试 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 最终打包后的效果 压缩包里的文件内容 lib中的文件 config配置文件 因为我没有写启动脚本，所以没有bin文件夹。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新功能-接口可以实现方法]]></title>
    <url>%2FJava8%E6%96%B0%E5%8A%9F%E8%83%BD-%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java8中，接口不仅仅可以定义方法，还可以实现方法 接口定义123456789101112public interface InterfaceTest &#123; default void test1() &#123; System.out.println("test1"); &#125; static int test2() &#123; System.out.println("test2"); return 0; &#125; String getName();&#125; 接口可以使用default和static两个修饰符定义方法，同一个方法不能同时使用这两个修饰符。 使用static修饰的方法，可以直接使用接口.方法名的方式进行调用。 使用default修饰的方法，在子类中无需重写，也可调用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新功能-lambda表达式]]></title>
    <url>%2FJava8%E6%96%B0%E5%8A%9F%E8%83%BD-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java8中新增的lambda表达式的介绍和用法 为什么需要lambda表达式场景在JDK8以前，如果我们需要临时创建一个线程，通常使用匿名内部类的方式实现。 123456789public void test1() &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread()); &#125; &#125;); thread.start();&#125; 当我们需要对集合进行自定义排序时，通常这么写 12345678910111213public void test2() &#123; List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add("tom"); names.add("jerry"); names.sort(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o1.length() - o2.length(); &#125; &#125;); System.out.println(names);&#125; 上面两个例子中，我们都是将一段代码当作参数，传入方法中。 使用lambda在JDK8中，我们可以使用lambda表达式简化代码。 创建线程 123456public void test3() &#123; Thread thread = new Thread(() -&gt; &#123; System.out.println(Thread.currentThread()); &#125;); thread.start();&#125; 自定义比较器 123456789public void test4() &#123; List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add("tom"); names.add("jerry"); names.sort((o1, o2) -&gt; &#123; return Integer.compare(o1.length(), o2.length()); &#125;); System.out.println(names);&#125; ()里写参数名，如果没有参数，可以不写。{}里写表达式，如果无法用一个表达式表示，也可以写多条语句。 12345names.sort((o1, o2) -&gt; &#123; System.out.println("123"); ... return Integer.compare(o1.length(), o2.length());&#125;); 参数的类型如果可以被推导，也可以省略。 如果需要赋值，也可以这样： 123Comparator&lt;String&gt; comparator = (o1, o2) -&gt; &#123; return Integer.compare(o1.length(), o2.length());&#125;;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring参数统一校验]]></title>
    <url>%2Fspring%E5%8F%82%E6%95%B0%E7%BB%9F%E4%B8%80%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[使用spring aop 实现特定接口参数统一校验 问题场景&emsp;&emsp;写过接口的人都会面临一个问题，那就是参数校验的问题。尽管客户端有参数校验，但经验告诉我们，仅仅依赖客户端是极大的错误。通常情况下，我们都应该认为，客户端传过来的参数都是不可信任的。每个参数都应该经过合理的校验才能使用，否则迟早会发生不可预料的问题。 &emsp;&emsp;基于上述的问题，最简单的解决办法就是在每个接口上，都加上参数校验。关键的地方来了，怎么加？接口少了还好说，修改代码就行，接口多了呢？几百个几千个，怎么办？ 使用AOP解决问题&emsp;&emsp;AOP(Aspect Oriented Programming )，中文叫面向切面编程。程序运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程 。其实本质上是一种动态代理技术。 &emsp;&emsp;有了AOP，我们就可以写一个通用的参数校验方法，对所有需要参数校验的接口进行统一处理了。而且对原来的代码没有侵入性，符合开闭原则。 下面是一个简单的例子： 1234567891011121314151617181920212223242526272829303132333435363738@Component@Aspectpublic class CheckParametersEmpty &#123; /** * 检查com.zbrx.speed.controller包下所有的返回值为ResultData的方法， * 如果参数有空，则阻止执行，并直接返回结果 * 否则继续执行 * @throws Throwable * */ @Around("execution(com.zbrx.speed.base.dto.ResultData com.zbrx.speed.controller..*.*(..))") public Object checkParam(ProceedingJoinPoint point) throws Throwable &#123; //获取方法的请求参数 Object[] params = point.getArgs(); //获取方法 Signature signature = point.getSignature(); MethodSignature methodSignature = (MethodSignature)signature; Method targetMethod = methodSignature.getMethod(); //检测方法上是否有 @IgnoreParams注解，如果有，则不检测参数，直接向下执行 IgnoreParams ignoreParams = targetMethod.getAnnotation(IgnoreParams.class); if (ignoreParams != null) &#123; //如果有注解 return point.proceed(params); //直接执行向下执行 &#125; //遍历参数，查看是否有空值 for (Object object : params) &#123; if (object == null) &#123; //如果参数有空值，直接返回 return ResultData.error(ResponseCode.PARAM_EMPTY); &#125; &#125; //否则继续往下执行 return point.proceed(params); &#125;&#125; @Around指定了切入点，也就是哪些方法需要进行参数校验。关于SpringAOP具体的介绍，我会在另一篇博客中说明。]]></content>
      <categories>
        <category>经验杂谈</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>aop</tag>
        <tag>经验杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理maven下载失败的jar包]]></title>
    <url>%2F%E6%B8%85%E7%90%86maven%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[下载失败包的特征maven下载失败的包，会使用.lastUpdated作为文件的结尾。如果不清除这些包，maven不会自动再次下载。 清理方法明白了maven的处理方法，就比较好解决了，直接删除本地仓库里以.lastUpdated结尾的文件就可以了。这里介绍下两种方法。 手动删除打开本地仓库目录，使用windows文件搜索功能，搜索出文件，删除即可。 使用代码删除毕竟咱是程序员，有问题还是自己写代码解决比较好😆。代码思路非常简单，递归出符合命名的文件，然后删除就可以了。 12345678910111213141516171819202122232425262728293031323334public class MavenClear &#123; public static void main(String[] args) &#123; String filePath = "E:\\test"; delete(filePath); &#125; /** * 根据路径删除下载失败的jar包，下载失败的包以 .lastUpdated结尾 * * @param filePath */ public static void delete(String filePath) &#123; File file = new File(filePath); if (file.exists()) &#123; // 判断是文件还是目录 if (file.isFile()) &#123; if (file.getName().endsWith("lastUpdated")) &#123; file.delete(); System.out.println("删除：" + file.getAbsoluteFile()); &#125; &#125; // 如果是目录 if (file.isDirectory()) &#123; // 获取目录，并循环递归 File[] files = file.listFiles(); for (File f : files) &#123; delete(f.getAbsolutePath()); &#125; &#125; &#125; &#125;&#125; 代码其实也没几行，可以将其打包成可执行文件，直接点击运行就可以了。]]></content>
      <categories>
        <category>奇淫巧技</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty hello world]]></title>
    <url>%2Fnetty-hello-world%2F</url>
    <content type="text"><![CDATA[Java NIO 框架netty的简单介绍以及hello world程序示例 Netty简介&emsp;&emsp;Netty是一款NIO客户端服务器框架，可以快速轻松地开发协议服务器和客户端等网络应用程序。 它极大地简化并简化了TCP和UDP套接字服务器等网络编程。 &emsp;&emsp;’快速和简单’并不意味着由此产生的应用程序将受到可维护性或性能问题的困扰。 Netty的设计经验非常丰富，包括FTP，SMTP，HTTP以及各种基于二进制和基于文本的传统协议等。 因此，Netty成功地找到了一种方法来实现轻松的开发，性能，稳定性和灵活性，而无需妥协。 &emsp;&emsp;以上内容摘自Netty官网。 不建议使用Java原生NIO编程的原因 NIO的类库和API繁杂，使用麻烦，需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。 需要具备其他额外的技能做铺垫，例如熟悉Java的多线程编程。这是因为NIO涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的NIO程序。 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。 JDK NIO的bug，例如臭名昭著的epoll bug，他会导致Selector空轮询，最终导致CPU100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本改问题依旧存在，只不过是发生的概率低了一些，并没有得到根本性的解决。 为什么选择Netty&emsp;&emsp;Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，他已经得到成百上千的商用项目验证，例如Haoop的RPC框架Avro就使用了Netty作为底层通信框架，其他还有业界主流的PRC框架，也使用Netty来构建高性能的异步通信能力。 Netty的优点如下： API使用简单，开发门槛低。 功能强大，预置了多种编解码功能，支持多种主流协议。 定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展。 性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优。 成熟、稳定，Netty修复了已经发现的所有JDK NIO bug，业务开发人员不需要在位NIO的bug烦恼。 社区活跃，版本迭代周期短，发现的bug可以被及时修复，同时，更多的新功能会加入。 经历了大规模的商业应用考验，质量得到验证。Netty在互联网、大数据、网络游戏、企业应用、电信软件等众多行业已经取得了成功商用，证明它已经完全能够满足不同行业的商业应用了。 Netty hello world Demo服务端自定义逻辑处理类 HelloServerHandler 123456789101112131415161718192021222324252627282930313233public class HelloServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; /** * 获取客户端发送的消息 * * @param channelHandlerContext * @param s * @throws Exception */ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123; // 收到消息直接打出 System.out.println(channelHandlerContext.channel().remoteAddress()+"说:" + s); // 向客户端发送消息 channelHandlerContext.writeAndFlush("服务器已收到消息，内容是：" + s + "\n"); &#125; /** * 建立连接后调用 * * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(ctx.channel().remoteAddress()+"连接！"); // 向客户端发送消息 ctx.writeAndFlush("欢迎登录"+InetAddress.getLocalHost().getHostName()+"\n"); &#125;&#125; IO事件初始化类 HelloServerInitializer 12345678910111213141516171819public class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); // 以("\n")为结尾分割的 解码器 pipeline.addLast("framer", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter())); // 字符串解码 和 编码 pipeline.addLast("decoder", new StringDecoder()); pipeline.addLast("encoder", new StringEncoder()); // 自己的逻辑Handler pipeline.addLast("handler", new HelloServerHandler()); &#125;&#125; 服务端启动类 Server 123456789101112131415161718192021222324252627282930313233343536public class Server &#123; /** * 监听端口 */ private static final int PORT = 8888; public static void main(String[] args) &#123; // 用于接受客户端连接的线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(); // 用于进行SocketChannel读写的线程组 EventLoopGroup workerGroup = new NioEventLoopGroup(); // netty启动类 ServerBootstrap server = new ServerBootstrap(); // 将线程组配置到启动类中 server.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) // 创建ServerSocketChannel .childHandler(new HelloServerInitializer()); // 绑定IO事件处理类 try &#123; System.out.println("服务端已启动，等待客户端连接..."); // 服务器绑定端口 ChannelFuture future = server.bind(PORT).sync(); // 等待服务端监听端口关闭后，main函数才退出 future.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放线程组资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 客户端自定义业务逻辑处理类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class HelloClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; private Thread thread = null; /** * 获取服务器发送的消息 * * @param channelHandlerContext * @param s * @throws Exception */ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123; System.out.println("服务器说："+s); &#125; /** * 建立连接后调用 * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; if (thread == null) &#123; thread = new Thread(() -&gt; &#123; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; String msg = scanner.next(); ctx.writeAndFlush(msg + "\n"); &#125; &#125;); thread.start(); &#125; &#125; /** * 与服务器断开连接后调用 * * @param ctx * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("客户端关闭"); super.channelInactive(ctx); &#125;&#125; IO事件初始化类 HelloClientInititlizer 123456789101112131415161718public class HelloClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); /* * 这个地方的 必须和服务端对应上。否则无法正常解码和编码 * */ pipeline.addLast("framer", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter())); pipeline.addLast("decoder", new StringDecoder()); pipeline.addLast("encoder", new StringEncoder()); // 客户端的逻辑 pipeline.addLast("handler", new HelloClientHandler()); &#125;&#125; 客户端启动类Client 123456789101112131415161718192021222324252627282930public class Client &#123; /** 服务器IP */ private static final String HOST = "127.0.0.1"; /** 服务器端口号 */ private static final int PORT = 8888; public static void main(String[] args) &#123; // 创建NIO线程组 EventLoopGroup group = new NioEventLoopGroup(); // 创建NIO客户端 Bootstrap client = new Bootstrap(); // 将线程组配置到启动类中，并创建SocketChannel，设置处理类 client.group(group).channel(NioSocketChannel.class) .handler(new HelloClientInitializer()); try &#123; // 发起异步连接操作 ChannelFuture future = client.connect(HOST, PORT).sync(); // 关闭连接后，主函数退出。 future.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放线程组资源 group.shutdownGracefully(); &#125; &#125;&#125; 分别启动Server 和 Client 后，控制台输出 Server控制台输出1234服务端已启动，等待客户端连接.../127.0.0.1:53521连接！/127.0.0.1:53521说:hello/127.0.0.1:53521说:world Client控制台输出1234服务器说：欢迎登录zhangxuhello world 服务器说：服务器已收到消息，内容是：hello服务器说：服务器已收到消息，内容是：world]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pipe管道]]></title>
    <url>%2FPipe%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324public class PipeTest &#123; public static void main(String[] args) throws IOException &#123; Pipe pipe = Pipe.open(); // 通过管道发送数据 Pipe.SinkChannel sink = pipe.sink(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); byteBuffer.put("通过管道发送数据".getBytes()); byteBuffer.flip(); sink.write(byteBuffer); byteBuffer.clear(); // 接受数据 Pipe.SourceChannel source = pipe.source(); int len = source.read(byteBuffer); byteBuffer.flip(); System.out.println(new String(byteBuffer.array(), 0, len)); byteBuffer.clear(); sink.close(); source.close(); &#125;&#125;]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阻塞模型与非阻塞模型]]></title>
    <url>%2F%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java NIO 中的阻塞模型与非阻塞模型的实现 阻塞与非阻塞&emsp;&emsp;传统的IO都是阻塞式的。也就是说，当一个线程调用read()或write()方法时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在网络通信进行IO操作时，由于线程会阻塞，所以服务端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。 &emsp;&emsp;Java NIO 是非阻塞模型的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或者有限几个线程来同时处理连接到服务器端的所有客户端。 Selector&emsp;&emsp;选择器，用于监听客户端与服务端的连接。调用通道的register(Selector sel, int ops)方法，将通道注册到选择器上，参数ops是常量，用于设置选择器的监听事件。可以监听的事件类型列表： 事件名称 功能 SelectionKey.OP_READ 读 SelectionKey.OP_WRITE 写 SelectionKey.OP_CONNECT 连接 SelectionKey.OP_ACCEPT 接收 当监听多个事件时，可以使用|操作符连接 SelectionKey.OP_READ | SelectionKey.OP_WRITE 演示代码阻塞方式1234567891011121314151617@Testpublic void client() throws IOException &#123; try ( // 1.获取通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 10000)); FileChannel fileChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); ) &#123; // 2.分配缓存 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (fileChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); // 3.发送数据到服务端 socketChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125;&#125; 12345678910111213141516171819202122232425@Testpublic void server() &#123; try ( // 1.获取通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); FileChannel fileChannel = FileChannel.open(Paths.get("c.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; // 2.绑定端口 serverSocketChannel.bind(new InetSocketAddress(10000)); // 3.获取客户端连接 SocketChannel socketChannel = serverSocketChannel.accept(); // 4.获取客户端的数据，保存到本地 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (socketChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); fileChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 非阻塞模式12345678910111213141516171819202122232425public class Client &#123; public static void main(String[] args) &#123; try ( // 打开通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("localhost", 8888)); ) &#123; // 设置非阻塞模式 socketChannel.configureBlocking(false); // 创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 发送数据 Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; String msg = scanner.next(); byteBuffer.put(msg.getBytes()); byteBuffer.flip(); socketChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Server &#123; public static void main(String[] args) &#123; try ( // 打开通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); ) &#123; // 绑定端口 serverSocketChannel.bind(new InetSocketAddress(8888)); //设置非阻塞模式 serverSocketChannel.configureBlocking(false); // 获取选择器 Selector selector = Selector.open(); // 注册连接事件 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (selector.select() &gt; 0) &#123; // 遍历注册事件，进行业务处理 Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); if (key.isAcceptable()) &#123; // 如果有客户端连接 SocketChannel socketChannel = serverSocketChannel.accept(); socketChannel.configureBlocking(false); // 注册读取事件，读取客户端发送的数据 socketChannel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; // 获取客户端的数据 SocketChannel socketChannel = (SocketChannel) key.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int len = 0; while ((len = socketChannel.read(byteBuffer)) &gt; 0) &#123; byteBuffer.flip(); System.out.println("[客户端]："+new String(byteBuffer.array(), 0, len)); byteBuffer.clear(); &#125; &#125; // 清除已处理的事件 it.remove(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Channel通道]]></title>
    <url>%2FChannel%E9%80%9A%E9%81%93%2F</url>
    <content type="text"><![CDATA[Channel通道的获取与原理 简介表示io源与目标打开的连接。Channel类似于传统的流，只不过Channel本身不能直接访问数据，Channel只能与Buffer进行交互。 Channel的主要实现类：FileChannel，SocketChannel，ServerSocketChannel，DatagramChannel 获取通道使用getChannel()方法1234567891011121314151617181920212223public void test1() throws FileNotFoundException &#123; try( FileInputStream fileInputStream = new FileInputStream("a.txt"); FileOutputStream fileOutputStream = new FileOutputStream("b.txt"); // 1.获取通道 FileChannel inChannel = fileInputStream.getChannel(); FileChannel outChannel = fileOutputStream.getChannel(); ) &#123; // 2.创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 3.将通道中的数据存入缓冲区 while (inChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); //切换到读数据模式 outChannel.write(byteBuffer); byteBuffer.clear(); //清空缓冲区 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 使用静态open()方法1234567891011121314151617public void test2() &#123; try( FileChannel inChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; // 内存映射文件 MappedByteBuffer inMappedByteBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMappedByteBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size()); byte[] dst = new byte[inMappedByteBuffer.limit()]; inMappedByteBuffer.get(dst); outMappedByteBuffer.put(dst); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 使用Files工具类中的静态方法 newByteChannel()1234567891011121314151617181920public void test3() &#123; try ( // 获取Channel，Files只能获取ByteChannel ByteChannel inChannel = Files.newByteChannel(Paths.get("a.txt"), StandardOpenOption.READ); ByteChannel outChannel = Files.newByteChannel(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; // 创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (inChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); outChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 通道之间的互相传输12345678910111213public void test4() &#123; try ( FileChannel inChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; //inChannel.transferTo(0, inChannel.size(), outChannel); // 或者 outChannel.transferFrom(inChannel, 0, inChannel.size()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 分散读取与聚集写入 12345678910111213141516171819public void test5() &#123; try ( FileChannel fileChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); ) &#123; // 分配缓冲区 ByteBuffer buffer1 = ByteBuffer.allocate(9); ByteBuffer buffer2 = ByteBuffer.allocate(6); ByteBuffer[] byteBuffers = &#123;buffer1, buffer2&#125;; // 分散读取 fileChannel.read(byteBuffers); for (ByteBuffer byteBuffer : byteBuffers) &#123; byteBuffer.flip(); System.out.println(byteBuffer + new String(byteBuffer.array())); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 123456789101112131415161718192021public void test6() &#123; try ( FileChannel inChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; ByteBuffer buffer1 = ByteBuffer.allocate(72); ByteBuffer buffer2 = ByteBuffer.allocate(72); ByteBuffer[] buffers = &#123;buffer1, buffer2&#125;; inChannel.read(buffers); for (ByteBuffer buffer : buffers) &#123; buffer.flip(); &#125; // 聚集写入 outChannel.write(buffers); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Java</tag>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Buffer缓冲区]]></title>
    <url>%2FBuffer%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[NIO 中Buffer缓冲区介绍及基本操作 简介Buffer(缓冲区)，在Java NIO中负责数据的存取。缓冲区本质上就是数组，用于存储不同数据类型的数据。 根据数据类型不同(boolean除外)，提供了相应类型的缓冲区 ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 缓冲区可以通过allocate()获取缓冲区 12// 创建一个指定大小的缓冲区ByteBuffer byteBuffer = ByteBuffer.allocate(1024); 直接缓冲区与非直接缓冲区通过allocate()方式创建的缓冲区，称为非直接缓冲区，这种缓冲区是在jvm中创建的。 通过allocateDirect()创建的缓冲区，称为直接缓冲区，这种缓冲区是在物理内存中直接创建的。 使用allocateDirect()所需要的成本比allocate()要高，而且无法使用垃圾自动回收。 四个核心属性 capacity：容量，表示缓冲区中最大存储数据的容量，一旦声明不能改变 limit：界限，表示缓冲区中可以操作数据的大小。(limit后数据不能进行读写)。 position：位置，表示缓冲区中正在操作数据的位置。 mark：标记，表示当前position的位置，可以通过reset()恢复到mark的位置 四个属性的关系：0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity 常用操作allocate()：创建缓冲区 1234ByteBuffer byteBuffer = ByteBuffer.allocate(1024);System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //1024System.out.println("capacity: "+byteBuffer.capacity()); //1024 put()：向缓冲区中写数据 12345String name = "tom";byteBuffer.put(name.getBytes());System.out.println("position: "+byteBuffer.position()); //3System.out.println("limit: "+byteBuffer.limit()); //1024System.out.println("capacity: "+byteBuffer.capacity()); //1024 flip()：切换到读数据模式 1234byteBuffer.flip();System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //3System.out.println("capacity: "+byteBuffer.capacity()); //1024 get()：读取缓冲区中的数据 123456byte[] dst = new byte[byteBuffer.limit()];byteBuffer.get(dst);System.out.println("buffer中的数据："+new String(dst, 0, dst.length));System.out.println("position: "+byteBuffer.position()); //3System.out.println("limit: "+byteBuffer.limit()); //3System.out.println("capacity: "+byteBuffer.capacity()); //1024 rewind()：重新从头读取数据 1234byteBuffer.rewind();System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //3System.out.println("capacity: "+byteBuffer.capacity()); //1024 clear()：清除缓冲区，数据依然存在。只是位置信息被初始化 1234byteBuffer.clear();System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //1024System.out.println("capacity: "+byteBuffer.capacity()); //1024 mark()：标记position的位置 1234byteBuffer.put("jerry".getBytes());byteBuffer.mark(); //当position为5时，进行标记byteBuffer.put("tom".getBytes());System.out.println("position: "+byteBuffer.position()); //8 reset()：恢复mark标记的position的位置 12byteBuffer.reset();System.out.println("position: "+byteBuffer.position()); //5]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Buffer</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO 概述]]></title>
    <url>%2FJava-NIO-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Java NIO简介 Java NIO 简介Java NIO(New IO / Non Blocking IO)是从Java1.4 版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有相同的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO以更加高效的方式进行文件的读写操作。 NIO与IO的区别 IO NIO 面向流(Stream Oriented) 面向缓冲区(Buffer Oriented) 阻塞IO(Blocking IO) 非阻塞IO(Non Blocking IO) 选择器(Selectors) 通道和缓冲区Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到IO设备(如：文件、套接字)的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。 缓冲区是一个用于存放特定基本数据类型的容器。由java.nio包定义，所有的缓冲区都是Buffer抽象类的子类。缓冲区主要用来与通道进行交互，数据从通道读入缓冲区，从缓冲区写入通道。]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些感悟]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[最近的一些感悟 &emsp;&emsp;有十天没有写过东西了，今天刚好周末，说静下心来写写东西吧，结果坐下来想了想，似乎并没有什么要写的。感觉这一周仿佛什么都没有做一样。再往深处想一想，一年仅仅52周，如果每周都是这个样子，那么一年也就是这个样子了。一年是这个样子，十年呢，二十年呢？细思极恐，一辈子碌碌无为恐怕就是这样的吧。 &emsp;&emsp;似乎我们身边的人都感觉时间是最不值钱的东西，我们可以整天待在家里抱着手机看一天的视频或者小说，仗着自己年轻，尽情挥霍着大把大把的时间。然后感叹一下，哎，今天又虚度了一天。结果第二天依然如此，日复一日，年复一年。 &emsp;&emsp;世间虽有很多的不公，但在时间上，是绝对公平的。每个人所拥有的时间都是完全一样的。人与人的区别就在于时间利用上的不同而体现出来的。有的人是重复昨天，而有的人是活在今天。勤学似春起之苗,不见其增,日有所长;辍学如磨刀之石,不见其损,日有所亏。 &emsp;&emsp;与君共勉。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>瞎写</tag>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型模式之简单工厂]]></title>
    <url>%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[简单工厂模式的介绍及写法 简单工厂模式提供一个创建对象实例的功能，而无需关心其具体的实现。被创建的实例类可以是接口，抽象类，也可以是具体的类。简单工厂并不在23中设计模式中，更多的时候是一种编程习惯。它通过接受不同的参数来返回不同的对象。 示例代码想象一个场景，你需要用笔写 一封信，有三种笔：铅笔，圆珠笔，中性笔，每种笔都有write()方法。 先定义笔接口 123public interface Pen &#123; void write(String words);&#125; 铅笔类 123456public class Pencil implements Pen &#123; @Override public void write(String words) &#123; System.out.println("使用铅笔写："+words); &#125;&#125; 圆珠笔类 123456public class BallpointPen implements Pen &#123; @Override public void write(String words) &#123; System.out.println("使用圆珠笔写："+words); &#125;&#125; 中性笔类 123456public class GelPen implements Pen &#123; @Override public void write(String words) &#123; System.out.println("使用中性笔写："+words); &#125;&#125; 下面是工厂类的具体实现 12345678910111213public class PenFactory &#123; public static Pen getPen(String penType) &#123; if ("pencil".equalsIgnoreCase(penType)) &#123; return new Pencil(); &#125; else if ("gelpen".equalsIgnoreCase(penType)) &#123; return new GelPen(); &#125; else if ("ballpointpen".equalsIgnoreCase(penType)) &#123; return new BallpointPen(); &#125; else &#123; return null; &#125; &#125;&#125; 这个工厂类根据不同的penType，new 不同的Pen对象。 在客户端调用 铅笔写 12Pen pencil = PenFactory.getPen("pencil");pencil.write("Hi tom!"); 圆珠笔写 12Pen ballpointPen = PenFactory.getPen("ballpointpen");ballpointPen.write("Hi tom!"); 中性笔写 12Pen gelPen = PenFactory.getPen("gelpen");gelpen.write("Hi tom!"); 客户端只需要从工厂取自己需要的产品就可以，不需要自己new，降低了耦合度。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>简单工厂</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型模式之单例模式]]></title>
    <url>%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式介绍与写法 什么是单例模式单例模式，顾名思义，单个实例的模式。保证一个类只有一个实例，并提供一个访问该实例的全局访问点。 为什么要有单例模式在某些场景下，某个类只允许一个实例。如操作系统的资源管理器，任务管理器，读取配置文件的类等。如果一个操作系统有多个资源管理器，那系统就乱套了。项目中读取配置文件的类如果有多个，则会浪费不必要的内存空间。 常见的五种单例模式的实现懒汉单例懒汉单例模式，只有当使用到单例对象时，才会进行实例化操作。 1234567891011121314151617181920212223242526272829303132333435363738public class Singleton1 implements Serializable&#123; /** * 懒汉单例，具体使用时才会实例化(懒加载) */ private static Singleton1 instance; /** * 私有化构造器，防止通过new创建对象 */ private Singleton1() &#123; //防止通过反射创建对象 if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; /** * 获取单例对象 * 延时加载，当使用对象时才实例化 * * @return */ public synchronized static Singleton1 getInstance() &#123; if (instance == null) &#123; instance = new Singleton1(); &#125; return instance; &#125; /** * 防止反序列化时创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125;&#125; 饿汉单例饿汉单例模式，类初始化时立即实例化对象。 12345678910111213141516171819202122232425public class Singleton2 implements Serializable &#123; /** * 饿汉单例模式，类初始化时创建对象 */ private static Singleton2 instance = new Singleton2(); private Singleton2() &#123; //防止反射创建单例对象 if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; public static Singleton2 getInstance() &#123; return instance; &#125; /** * 防止反序列化创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125; 双重检查锁式单例在jdk1.5之前，使用这种方式偶尔会有问题，不建议使用。 123456789101112131415161718192021222324252627282930313233public class Singleton3 &#123; private static volatile Singleton3 instance; private Singleton3() &#123; if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; /** * 双重检查锁单例 * @return */ public static Singleton3 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton3.class) &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; &#125; &#125; return instance; &#125; /** * 防止反序列化创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125;&#125; 静态内部类式单例线程安全，调用效率高，延时加载，推荐使用这种方式。 123456789101112131415161718192021222324252627282930public class Singleton4 implements Serializable &#123; /** * 创建静态内部类 */ private static class SingletonClassInstance &#123; private static final Singleton4 instance = new Singleton4(); &#125; /** * 私有化构造方法 */ private Singleton4() &#123; if (SingletonClassInstance.instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; public static Singleton4 getInstance() &#123; return SingletonClassInstance.instance; &#125; /** * 防止反序列化创建新对象 * * @return */ private Object readResolve() &#123; return SingletonClassInstance.instance; &#125;&#125; 枚举单例12345678910public enum Singleton5 &#123; INSTANCE; /** * 自定义操作 */ public void operation() &#123; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式概述]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[四人帮23种设计模式概述 什么是设计模式&emsp;&emsp;设计模式，是指在软件开发中，经过验证的，用于解决在特定环境下，重复出现的、特定问题的解决方案。通俗的说，就是解决特定问题的套路方法。 为什么要学设计模式 他山之石，可以攻玉。学习别人解决问题的思路，以后自己碰到了就可以很好的解决同样的问题。 提升逼格。让自己的代码更优雅，更有设计感。 如何学习设计模式 心态要稳，学习要狠。不要指望一步登天，心浮气躁。 理论与实践相结合。多写多思考，在实际开发中使用，然后再结合理论思考，然后再应用，再思考……如此循环，反复多次，直到达到对设计模式掌握的水平。 学习设计模式的三个层次鹦鹉学舌&emsp;&emsp;能够正确理解和掌握每个设计模式的基本知识，能够识别在什么场景下，出现了什么样的问题，采用何种方案解决它，并能够在实际的程序设计和开发中套用相应的设计模式。 照猫画虎&emsp;&emsp;能根据具体的实际情况，对设计模式进行适当的变形使用，能够确保正确使用设计模式，而不是生搬硬套。 学以致用&emsp;&emsp;真正的设计模式是没有模式。从本质上已经掌握了设计模式的精髓，并完全融入到了自己的思想中。在设计程序的时候，可以随意的，自然而然的运用。 上面基本都是废话，下面来点干货。 设计模式的六大原则开闭原则一个软件的实体(类、方法、模块等)，应该对扩展开放，对修改关闭。 依赖倒置原则高层模块不应该依赖底层模块，两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。 迪米特法则如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 单一职责原则一个类只做一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。 里氏替换原则接口或类出现的地方，他们的实现或者子类可以完全替换调他们。 接口隔离原则不要提供一个大的接口包含所有功能，要根据功能把这些接口分割，减少依赖。 设计模式分类创建型模式创建型模式有五种。 单例模式、工厂模式、建造者模式、原型模式、适配器模式。 结构型模式结构型模式有七种。 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为模式行为模式有十一种。 模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。 从封装变化角度分类组件协作模板方法、策略模式、观察者模式 单一职责装饰模式、桥接模式 对象创建工厂模式、抽象工厂模式、原型模式、建造者模式 对象性能单例模式、享元模式 接口隔离外观模式、代理模式、中介者模式、适配器模式 状态变化备忘录模式、状态模式 数据结构组合模式、迭代器模式、责任链模式 行为变化命令模式、访问者模式 领域问题解释器模式 重构获得模式面向对象设计模式是“好的面向对象设计”，所谓“面向对象设计”，指的是那些可以满足“应对变化，提高复用”设计。 现代软件的设计特征是“需求的频繁变化”。设计模式的要点是“寻找变化点，然后在变化点处应用设计模式”，从而来更好的应对需求的变化。什么时候，什么地点应用设计模式，比理解设计模式本身更为重要。 设计模式的应用不宜先入为主，一上来就使用设计模式，是对设计模式的最大误用。没有一步到位的设计模式，敏捷开发实践提倡的“Refactoring to Patterns”是目前普遍公认的最好的使用设计模式的方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo上传图片]]></title>
    <url>%2FHexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[自己写的简单客户端，解决上传到云图床的痛点。 之前的做法&emsp;&emsp;陆陆续续也写了有七八篇博客了，其他的感觉都还不错，就是图片上传体验并不愉快。我用的腾讯云图床存储图片，但我所使用的markdown编辑器并不提供上传图片的插件，腾讯云也没有客户端，只有网页版，所以只能是打开腾讯云后台上传图片，然后将图片的访问地址粘贴到编辑器中，刚开始感觉也不算什么麻烦事，但时间一长，来来回回的切换，就感觉不是那么方便了。 没有枪，没有炮，自己造。 &emsp;&emsp;既然咱是程序员，那就应该干点程序员该干的事，没有怎么办？自己写一个！ 开始干&emsp;&emsp;其实这个需求很简单，把文件传到服务器，返回个访问地址就可以了。想明白需求，那就简单了。然而，需求是明确了，痛处也来了——我并不熟悉桌面程序的写法😱。虽说干开发也有两年多了，但都是开发web项目，并没有写过桌面程序。只是刚刚接触Java时，学过一点点，但两年时间了，早就忘得一干二净了。 不过这点小困难可难不倒咱，正好身边有本书，那就现学现卖喽。 说起这本书，从买下到现在应该也有差不多四年了，也就刚刚买下那段时间看了看，现在基本都在吃灰，实在惭愧b(￣▽￣)d 扯远了，说正事。反正是逮着书一顿猛看，算是稍微有点印象了。然后着手开始写，写着写着，有些地方忘了，又回头看书，如此反反复复多次后，总算是有些样子了。写完抬起头看看窗外，天都黑了。 鲁迅曾说过： 有些时候，人总是将问题看的很简单，但当你去做的时候，发现其实并不是那么回事。 好吧，这句话是我编的，写程序都写出哲理了，感觉也是萌萌哒😵。 总之，不管怎么样，东西总算是做出来了，下面介绍下我的处女作。 程序基本介绍 如你所见，这个就是程序的主界面，功能简洁明了，遵循极简主义设计😂。下面介绍下使用方法： 选择文件点击选择文件按钮，弹出文件选择框，选中文件。 返回界面后，显示待上传文件列表 图片是单选的，如果要选多张图片，需要选多次。 好吧，我知道这点不好，本来做成了多选的，但那个多选文件的框太丑，而且不能预览图片，所以最终选择了这种方式。 上传文件上传没什么好说的，直接点击上传就可以了。 当没有选择文件，点击上传时： 历史记录显示上传历史。 未上传过文件，点击历史记录时： 清除内容清除主页面所有的显示。 清除内容不会清除历史，只会清除显示的文字。历史记录是存储在文本中的。 最后如果你我瞎鼓捣出的这个小玩意感兴趣，我打包好放到百度云盘了，下载就可以用，如果需要源码，直接邮箱联系我，我会抽时间发过去的。 软件使用时，需要在配置文件中配置自己的腾讯云相关参数。 点击这里下载]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>上传图片</tag>
        <tag>云图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo写作样式简介]]></title>
    <url>%2FHexo%E5%86%99%E4%BD%9C%E6%A0%B7%E5%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[使用Hexo中自带的写作样式，丰富文章表现形式 note标签修改主题配置文件_config.yml 12345note: style: flat icons: true border_radius: 3 light_bg_offset: 0 default 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; primary 1&lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt; success 1&lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt; info 1&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt; warning 1&lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt; danger 1&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; tabs标签选项卡 1选项卡 2选项卡 3选项卡 1 选项卡 2 这是选项卡 3 上面的，3表示打开页面时，默认展示第三个选项卡 1234567891011&#123;% tabs 选项卡, 3 %&#125;&lt;!-- tab --&gt;**选项卡 1**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 3**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 图标 照相机 电池 hexo 使用的是fontawesome图标，直接引用就可以 121. &lt;i class="fa fa-camera"&gt;&lt;/i&gt; 照相机2. &lt;i class="fa fa-battery-4"&gt;&lt;/i&gt; 电池 按钮google一下 1&#123;% btn https://www.google.com, google一下, google fa-fw %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>写作样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用git]]></title>
    <url>%2FIntelliJ-IDEA-%E4%BD%BF%E7%94%A8git%2F</url>
    <content type="text"><![CDATA[介绍了IDEA中如何使用git IDEA中git的配置使用Ctrl+Alt+S打开设置 如图所示进行配置，配置完场后点击Test按钮，如果弹出版本号表示配置成功。 项目中使用gitgit检出项目 填写完地址后，点击Clone就可以检出项目了。 为项目添加git版本控制如图所示，为项目创建一个本地git版本库 选择当前项目文件夹，创建版本库 项目右键，将项目添加到版本控制中 提交项目到本地的仓库 填写提交说明，点击提交 连接到远程仓库 设置远程仓库位置 推送到远程仓库]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java String split的坑]]></title>
    <url>%2Fjava-String-split%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一个关于Java String split方法的坑 Java的String中，有一个方法split() 1public String[] split(String regex) 这个方法根据给定的正则表达式，去切分目标字符串，并返回切分后的结果。 简单的测试代码： 123456@Testpublic void test1() &#123; System.out.println(Arrays.toString("1,2".split(",")));&#125;// 输出结果：[1, 2] 上面的代码，输出结果完全符合预期。然而，当把代码做如下修改时： 123456@Testpublic void test2() &#123; System.out.println(Arrays.toString("1.2".split(".")));&#125;// 输出结果：[] 难道不应该输出 [1, 2]吗？ 其实问题就出在split的参数上，在Java中，有些特殊符号输入时，是必须要转义的 \。 将参数改为\\.，就能输出正确结果了 123456@Testpublic void test3() &#123; System.out.println(Arrays.toString("1.2".split("\\.")));&#125;// 输出结果：[1, 2]]]></content>
      <categories>
        <category>踩坑记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由拆装箱引起的性能问题]]></title>
    <url>%2F%E7%94%B1%E6%8B%86%E8%A3%85%E7%AE%B1%E5%BC%95%E8%B5%B7%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Integer.valueOf与Integer.parseInt引发的性能问题 问题代码1int a = Integer.valueOf(request.getParameter("baseProjectId")) 这段代码看上去没什么问题，但其实会有性能上的浪费，Integer.valueOf()的部分源码： 12345678910public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10)); // 注意parseInt这句&#125;public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 由代码可以看出，Integer.valueOf() 先调用parseInt()解析字符串，然后再调用方法，将int转换为Integer对象，然后返回Integer对象。结合上面的问题代码，整个类型转换流程为： 1String --&gt; int --&gt; Integer --&gt; int 在此过程中，不仅创建了一个临时对象，浪费内存，而且进行了一次拆装箱操作，浪费了性能。 更改建议直接将Integer.valueOf()改为Integer.parseInt() 1int a = Integer.parseInt(request.getParameter("baseProjectId"))]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解防盗链]]></title>
    <url>%2F%E7%A0%B4%E8%A7%A3%E9%98%B2%E7%9B%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[用简单粗暴的方式破解防盗链 什么是盗链简单来说，有两个网站，A和B。A网站有一张图片 1&lt;img src="http://xxx/a.png" /&gt; B网站看到了这张图片，他不下载，直接将图片的地址放到了自己的服务器上。那么当用户访问B站点时，实际却跑的是A站点的流量和服务，从而不劳而获，这就是盗链。 referrer为了解决这种事情，HTTP协议规定：浏览器在加载非本站资源时，会增加如下请求头： 1Referer: http://localhost:8080/temp/b.html 这个Referer标签是告诉请求者，引用这个资源的站点是谁 防盗链原理一般的站点，会根据Referer来进行防盗链工作，当请求头存在Referer时，即为非法引用，此时服务器拒绝服务，从而达到防盗链的目的。具体的实现有很多种，此处不细讲了，可自行Google。 破解防盗链了解了防盗链的基本原理后，破解就简单多了。只要想办法在请求的时候取消请求头中的Referer就可以了。这里破解也有好多种办法，可以使用nginx反向代理，或者使用iframe等等。这里介绍一种我认为相对来说最简单的办法： 1&lt;meta name="referrer" content="never"&gt; 只要在html中加入上面的meta标签，就可以破解简单的防盗链了。这个meta标签的意思是告诉浏览器，请求时不用包含referer相关的信息，从而达到破解防盗链的目的。 referer与referrer有人觉得很奇怪，浏览器中的请求头是referer，怎么标签里的是referrer，其实标签中的referrer才是正确的单词，据说是当时HTTP协议的制定者将单词拼错，大家就将错就错的使用了。具体可看维基百科的 HTTP来源地址 词条]]></content>
      <categories>
        <category>奇淫巧技</category>
      </categories>
      <tags>
        <tag>奇淫巧技</tag>
        <tag>防盗链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建git服务器]]></title>
    <url>%2F%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本地搭建git服务器 前言&emsp;&emsp;git可以说是目前使用最广泛的版本控制系统了，GitHub是基于git的免费的代码托管网站，有人说，既然都是免费的了，直接用不就好了吗，干嘛还要费劲自己搭建一个服务。我想说的是，GitHub虽然是免费的，但是有一点很重要，那就是私有性。公司内部的项目通常都是要保密的。虽然GitHub可以选择仓库私有，但那是要收费的。综上所述，还是在自己私有的服务器上搭建git服务比较合适。 &emsp;&emsp;本次演示使用VMware虚拟机，系统镜像CentOS 6.9 x64，root账户进行安装操作。 正文开始安装git使用yum查询当前是否有可安装的git版本 1[root@hadoop03 home]# yum info git 使用yum安装git 1[root@hadoop03 ~]# yum install -y git 检查是否安装成功 12[root@hadoop03 ~]# git versiongit version 1.7.1 创建git运行用户1[root@hadoop03 ~]# adduser git 在当前Linux系统中创建了一个新的用户git。 执行完以上命令后，会在/home生成一个git文件夹。我们cd到home目录查看一下 123[root@hadoop03 git]# cd /home/git[root@hadoop03 git]# ls -a. .. .bash_logout .bash_profile .bashrc .gnome2 .mozilla 禁止git用户shell登录创建git用户是为了访问服务器的git仓库，为了安全起见，将git用户禁止shell登录。 1[root@hadoop03 ~]# vi /etc/passwd 找到类似下面的一句 1git:x:501:501::/home/git:/bin/bash 将其改为 1git:x:1001:1001::/home/git:/usr/bin/git-shell 保存即可 创建ssh证书登录在/home/git文件夹下，创建一个新文件夹.ssh，并新建一个文件authorized_keys，这个authorized_keys文件用来存放我们的git公钥。 1234567[root@hadoop03 git]# mkdir .ssh[root@hadoop03 git]# chmod 755 .ssh/[root@hadoop03 git]# cd .ssh[root@hadoop03 .ssh]# touch authorized_keys[root@hadoop03 .ssh]# chmod 600 authorized_keys[root@hadoop03 .ssh]# lsauthorized_keys 收集团队中其他人的git公钥，复制后添加到authorized_keys文件中。git公钥一般存放在C:\Users\xxx\.ssh\id_rsa.pub中。如果你的电脑上没有，需要安装git客户端，并生成git公钥。关于此部分，我的另一篇博客使用GitHub-Pages-Hexo-搭建博客中有所介绍，此处不再细讲。 1[root@hadoop03 git]# vim authorized_keys 粘贴公钥后，保存即可。 注意：粘贴公钥时，注意空格。公钥一行一个。 .ssh 和 authorized_keys 需要授予权限，否则git clone 项目时，会提示输入密码，此处必须注意！ 初始化git仓库创建一个仓库目录，我放在/home/gitrepo下面 123[root@hadoop03 home]# mkdir gitrepo[root@hadoop03 home]# lsgit gitrepo 初始化git仓库，假设项目名叫test 123[root@hadoop03 home]# cd gitrepo/[root@hadoop03 gitrepo]# git init --bare test.gitInitialized empty Git repository in /home/gitrepo/test.git/ 执行完命令后，会在gitrepo下生成test.git目录 12[root@hadoop03 gitrepo]# lstest.git 修改仓库的归属权限，否则无法访问git仓库 1[root@hadoop03 gitrepo]# chown -R git:git test.git/ 至此，git服务器搭建完成。 克隆远程仓库1234λ git clone git@192.168.213.130:/home/gitrepo/test.gitCloning into 'test'...key_load_public: invalid formatwarning: You appear to have cloned an empty repository. 接下来就尽情使用git吧。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub Pages + Hexo 搭建博客]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用Github Pages + Hexo 自建博客的详细流程。包括创建GitHub账号，创建仓库，设置git客户端连接，ssh公钥，安装配置Hexo并部署，设置Hexo next主题，自定义域名。 折腾了近一个星期，终于将博客搭建成功了，现在将具体的过程写出来，以帮助需要自建博客的人。 GitHub部分注册GitHub账号要使用GitHub Pages，需要先注册GitHub账号，注册链接 注册流程就不细说了，相信大家都会注册的。 注册完成后，需要邮箱激活，请进入自己的注册邮箱，完成激活即可。 创建Git仓库Git repository(仓库) 用于存放博客内容 上面的按钮随便点击一个都可以跳转到创建仓库页面 私有仓库是收费的，公共仓库是免费的，这个根据情况自己选择即可。 仓库设置仓库创建成功后，进入仓库主页 点击进入仓库设置 如果创建时仓库名字是 自己的用户名.github.io，则以上的选项默认是选中的。 至此，创建仓库就完成了，此时打开浏览器，输入 自己的用户名.github.io就能访问自己的主页了。 安装Git客户端仓库创建完成后，需要安装Git客户端与Git仓库进行连接，方便我们在本地提交博客。 根据自己的操作系统，下载git客户端 ，完成安装。 设置git环境变量打开git的安装目录，并复制安装路径。 桌面上找到我的电脑 – &gt; 右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 –&gt; 系统变量 –&gt; Path 新建变量值，将刚刚复制的路径填进去，并在末尾加上\cmd，保存即可 测试环境变量是否配置成功，打开命令行输入 1git version 输出版本号，表示配置成功。 设置用户名和邮箱鼠标点击右键，选择Git Bash Here，打开git bash客户端 12git config --global user.name "zhangsan"git config --global user.email "zhangsan@sina.com" 生成ssh密钥1ssh-keygen -t rsa -C "zhangsan@sina.com" 连续回车即可。 设置GitHub公钥打开目录C:\Users\你自己的用户名\.ssh下，会有两个文件 id_rsa(私钥) id_rsa.pub(公钥) ，使用文本编辑器打开id_rsa.pub，复制里面的内容，登录GitHub，进入个人设置中心。 开始设置ssh 新建ssh key 填入公钥 点击 Add SSH key就可以了。 在本地测试连接 1ssh -T git@github.com 当输出以下内容时，表示连接成功。 Hexo部分安装nodejs根据自己的操作系统平台，下载nodejs，并安装。 nodejs环境变量安装好后，会自己添加到环境变量中，一般不需设置。 设置node环境变量和git环境变量类似，请参考git环境变量的配置。 注意：此处编辑变量值时，不需要在后面加\cmd，直接复制路径即可。 配置完成后，命令行输入 1node --version 输出版本号，表示配置成功。 安装Hexo使用npm安装Hexo，npm是nodejs自带的包依赖管理工具，类似于Centos中的yum。 1npm install -g hexo-cli 强烈建议浏览 Hexo官方文档，写的非常详细。 初始化博客123hexo init 自定义文件夹cd 自定义文件夹npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml #博客的全局配置文件├── package.json #包含了应用程序的信息├── scaffolds #模板文件夹├── source #用户资源文件夹| ├── _drafts #草稿箱| └── _posts #写的文章放到这里└── themes #主题文件夹 _config.yml文件详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo #网站标题subtitle: #网站副标题description: #网站描述keywords: #关键字author: John Doe #网站作者language: #网站所使用的语言 中文使用 zh-Hans 防止乱码timezone: #网站时区 Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com #网址root: / #网站根目录permalink: :year/:month/:day/:title/ #文章的 永久链接 格式permalink_defaults: #永久链接中各部分的默认值# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 # http://yoursite.com/blog 并把 root 设为 /blog/。# Directorysource_dir: source #资源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 # Writingnew_post_name: :title.md #新文章的文件名称default_layout: post #预设布局titlecase: false #把标题转换为 title caseexternal_link: true #在新标签中打开链接filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址future: true #显示未来的文章highlight: #代码块的设置 enable: true #是否开启代码块支持 line_number: true #显示行号 auto_detect: false tab_replace: #设置用什么字符替代Tab，如tab_replace: aaa，在代码中将输入tab的地方替换为aaa # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式# Pagination## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章条数pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape #当前所使用的主题名# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #部署部分设置 type: #部署类型 根据需要更改配置文件，进行个性化配置 启动Hexo服务初始化完成后，就可以启动Hexo服务了，进入博客目录，执行以下命令，即可启动服务 12hexo g #生成静态文件hexo s #启动hexo服务 打开浏览器，输入http://localhost:4000/ 配置了这么长时间，终于看到点效果了，有没有很激动O(∩_∩)O Hexo基本命令1234567hexo generate #生成静态文件，可以简写为 hexo ghexo clean #清除生成的静态文件hexo server #启动hexo服务进行预览，可以简写为 hexo shexo deploy #部署到服务器，可以简写为hexo dhexo new "文件名" #创建新文章hexo new draft "文件名" #创建草稿箱文章hexo new page "页面名" #创建新页面 配置部署到GitHub更改_config.yml配置文件的deploy部分。 1234deploy: type: git repo: https://github.com/xxx/xxx.github.io.git branch: master #部署的分支 或者 1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master #部署的分支 部署到GitHub1hexo d 自定义域名首先要有注册好的域名，没有的话，可以先去注册。域名的注册这里不多介绍了，资料很多，大家可以自己选择域名注册商进行注册。 CNAME类型解析注册好域名后，在博客的资源文件夹source下创建一个文件，CNAME，注意，这个文件没有后缀。使用文本编辑器打开，填入自己的域名，并保存。 登录自己的域名解析后台，添加一条解析记录。记录类型选择CNAME，记录值填入之前GItHub分配的访问路径xxx.github.io，保存后就可以用自己的域名访问博客了。 注意：CNAME文件一定要放在source路径下，否则下次部署的时候，CNAME就被删除了。 A类型解析在自己的域名解析后台添加一条解析记录，记录类型选择A，记录值填写自己项目访问路径的IP地址。如果不清楚IP地址，可以通过ping 项目访问路径的方式获得，然后填入记录值中即可。 Hexo更换next主题安装next主题建议根据官方文档安装，遇到不明白的地方再找别的资料参考 next官方文档 Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。 cd 到你的博客路径下，使用git下载主题文件 1git clone https://github.com/iissnan/hexo-theme-next themes/next 修改博客配置文件_config.yml，将theme: landscape修改为theme: next 启动服务即可。 上面的界面是我美化后的效果，图片仅供参考。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>自建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要写博客]]></title>
    <url>%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[关于写博客，自建博客的一些个人看法 写博客的原因记录解决问题的步骤，方便查阅&emsp;&emsp;首先作为程序员来讲，工作中都会遇到很多自己解决不了的问题。很多时候自己都是习惯去Google，或者各个博客看别人的解决办法，然后尝试解决问题。在这个过程中，发现很多人写的都是错误的，经常是按照A写的做，做完发现不对，又按照B写的做，发现又不对…… 最后终于将问题解决了，过一段时间遇到相同的问题，却又想不起来当初是怎么解决的。有了博客，就可以记录查阅了。 知识，只有自己总结后，才是自己的&emsp;&emsp;俗话说眼过千遍，不如手过一遍。这句话在编程界尤为适用。某个知识点，看着别人写的，感觉自己都会了，等到自己动手写的时候，脑子里空空如也，半棍子打不出一个屁来。有了博客，在写博客的时候，就会强迫自己将知识点深入理解，也算是知识梳理的过程吧。 提高写作水平&emsp;&emsp;其实自己一直有一个写作的梦想，当年读高中时，还曾经写过一本侦探小说🤣。写博客，可以练习练习语言组织能力，天天写代码，有时候连话都说不太清了。 自建博客的原因不信任第三方博客&emsp;&emsp;网络世界错综复杂，各个博客平台此消彼长。说不定到那一天，自己所在的平台就消失了，到时候当初自己辛辛苦苦写的东西也就随之消失。这是一件非常痛心的事情。 自己的地盘，可以尽情折腾&emsp;&emsp;大概程序员都喜欢自己折腾吧。自建博客，所有的东西都是自己说了算，感觉非常自由。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
