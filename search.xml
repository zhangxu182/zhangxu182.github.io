<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[netty hello world]]></title>
    <url>%2Fnetty-hello-world%2F</url>
    <content type="text"><![CDATA[Java NIO 框架netty的简单介绍以及hello world程序示例 Netty简介&emsp;&emsp;Netty是一款NIO客户端服务器框架，可以快速轻松地开发协议服务器和客户端等网络应用程序。 它极大地简化并简化了TCP和UDP套接字服务器等网络编程。 &emsp;&emsp;’快速和简单’并不意味着由此产生的应用程序将受到可维护性或性能问题的困扰。 Netty的设计经验非常丰富，包括FTP，SMTP，HTTP以及各种基于二进制和基于文本的传统协议等。 因此，Netty成功地找到了一种方法来实现轻松的开发，性能，稳定性和灵活性，而无需妥协。 &emsp;&emsp;以上内容摘自Netty官网。 不建议使用Java原生NIO编程的原因 NIO的类库和API繁杂，使用麻烦，需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。 需要具备其他额外的技能做铺垫，例如熟悉Java的多线程编程。这是因为NIO涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的NIO程序。 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。 JDK NIO的bug，例如臭名昭著的epoll bug，他会导致Selector空轮询，最终导致CPU100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本改问题依旧存在，只不过是发生的概率低了一些，并没有得到根本性的解决。 为什么选择Netty&emsp;&emsp;Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，他已经得到成百上千的商用项目验证，例如Haoop的RPC框架Avro就使用了Netty作为底层通信框架，其他还有业界主流的PRC框架，也使用Netty来构建高性能的异步通信能力。 Netty的优点如下： API使用简单，开发门槛低。 功能强大，预置了多种编解码功能，支持多种主流协议。 定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展。 性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优。 成熟、稳定，Netty修复了已经发现的所有JDK NIO bug，业务开发人员不需要在位NIO的bug烦恼。 社区活跃，版本迭代周期短，发现的bug可以被及时修复，同时，更多的新功能会加入。 经历了大规模的商业应用考验，质量得到验证。Netty在互联网、大数据、网络游戏、企业应用、电信软件等众多行业已经取得了成功商用，证明它已经完全能够满足不同行业的商业应用了。 Netty hello world Demo服务端自定义逻辑处理类 HelloServerHandler 123456789101112131415161718192021222324252627282930313233public class HelloServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; /** * 获取客户端发送的消息 * * @param channelHandlerContext * @param s * @throws Exception */ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123; // 收到消息直接打出 System.out.println(channelHandlerContext.channel().remoteAddress()+"说:" + s); // 向客户端发送消息 channelHandlerContext.writeAndFlush("服务器已收到消息，内容是：" + s + "\n"); &#125; /** * 建立连接后调用 * * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(ctx.channel().remoteAddress()+"连接！"); // 向客户端发送消息 ctx.writeAndFlush("欢迎登录"+InetAddress.getLocalHost().getHostName()+"\n"); &#125;&#125; IO事件初始化类 HelloServerInitializer 12345678910111213141516171819public class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); // 以("\n")为结尾分割的 解码器 pipeline.addLast("framer", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter())); // 字符串解码 和 编码 pipeline.addLast("decoder", new StringDecoder()); pipeline.addLast("encoder", new StringEncoder()); // 自己的逻辑Handler pipeline.addLast("handler", new HelloServerHandler()); &#125;&#125; 服务端启动类 Server 123456789101112131415161718192021222324252627282930313233343536public class Server &#123; /** * 监听端口 */ private static final int PORT = 8888; public static void main(String[] args) &#123; // 用于接受客户端连接的线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(); // 用于进行SocketChannel读写的线程组 EventLoopGroup workerGroup = new NioEventLoopGroup(); // netty启动类 ServerBootstrap server = new ServerBootstrap(); // 将线程组配置到启动类中 server.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) // 创建ServerSocketChannel .childHandler(new HelloServerInitializer()); // 绑定IO事件处理类 try &#123; System.out.println("服务端已启动，等待客户端连接..."); // 服务器绑定端口 ChannelFuture future = server.bind(PORT).sync(); // 等待服务端监听端口关闭后，main函数才退出 future.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放线程组资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 客户端自定义业务逻辑处理类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class HelloClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; private Thread thread = null; /** * 获取服务器发送的消息 * * @param channelHandlerContext * @param s * @throws Exception */ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123; System.out.println("服务器说："+s); &#125; /** * 建立连接后调用 * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; if (thread == null) &#123; thread = new Thread(() -&gt; &#123; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; String msg = scanner.next(); ctx.writeAndFlush(msg + "\n"); &#125; &#125;); thread.start(); &#125; &#125; /** * 与服务器断开连接后调用 * * @param ctx * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("客户端关闭"); super.channelInactive(ctx); &#125;&#125; IO事件初始化类 HelloClientInititlizer 123456789101112131415161718public class HelloClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); /* * 这个地方的 必须和服务端对应上。否则无法正常解码和编码 * */ pipeline.addLast("framer", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter())); pipeline.addLast("decoder", new StringDecoder()); pipeline.addLast("encoder", new StringEncoder()); // 客户端的逻辑 pipeline.addLast("handler", new HelloClientHandler()); &#125;&#125; 客户端启动类Client 123456789101112131415161718192021222324252627282930public class Client &#123; /** 服务器IP */ private static final String HOST = "127.0.0.1"; /** 服务器端口号 */ private static final int PORT = 8888; public static void main(String[] args) &#123; // 创建NIO线程组 EventLoopGroup group = new NioEventLoopGroup(); // 创建NIO客户端 Bootstrap client = new Bootstrap(); // 将线程组配置到启动类中，并创建SocketChannel，设置处理类 client.group(group).channel(NioSocketChannel.class) .handler(new HelloClientInitializer()); try &#123; // 发起异步连接操作 ChannelFuture future = client.connect(HOST, PORT).sync(); // 关闭连接后，主函数退出。 future.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放线程组资源 group.shutdownGracefully(); &#125; &#125;&#125; 分别启动Server 和 Client 后，控制台输出 Server控制台输出1234服务端已启动，等待客户端连接.../127.0.0.1:53521连接！/127.0.0.1:53521说:hello/127.0.0.1:53521说:world Client控制台输出1234服务器说：欢迎登录zhangxuhello world 服务器说：服务器已收到消息，内容是：hello服务器说：服务器已收到消息，内容是：world]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pipe管道]]></title>
    <url>%2FPipe%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324public class PipeTest &#123; public static void main(String[] args) throws IOException &#123; Pipe pipe = Pipe.open(); // 通过管道发送数据 Pipe.SinkChannel sink = pipe.sink(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); byteBuffer.put("通过管道发送数据".getBytes()); byteBuffer.flip(); sink.write(byteBuffer); byteBuffer.clear(); // 接受数据 Pipe.SourceChannel source = pipe.source(); int len = source.read(byteBuffer); byteBuffer.flip(); System.out.println(new String(byteBuffer.array(), 0, len)); byteBuffer.clear(); sink.close(); source.close(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阻塞模型与非阻塞模型]]></title>
    <url>%2F%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java NIO 中的阻塞模型与非阻塞模型的实现 阻塞与非阻塞&emsp;&emsp;传统的IO都是阻塞式的。也就是说，当一个线程调用read()或write()方法时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在网络通信进行IO操作时，由于线程会阻塞，所以服务端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。 &emsp;&emsp;Java NIO 是非阻塞模型的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或者有限几个线程来同时处理连接到服务器端的所有客户端。 Selector&emsp;&emsp;选择器，用于监听客户端与服务端的连接。调用通道的register(Selector sel, int ops)方法，将通道注册到选择器上，参数ops是常量，用于设置选择器的监听事件。可以监听的事件类型列表： 事件名称 功能 SelectionKey.OP_READ 读 SelectionKey.OP_WRITE 写 SelectionKey.OP_CONNECT 连接 SelectionKey.OP_ACCEPT 接收 当监听多个事件时，可以使用|操作符连接 SelectionKey.OP_READ | SelectionKey.OP_WRITE 演示代码阻塞方式1234567891011121314151617@Testpublic void client() throws IOException &#123; try ( // 1.获取通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 10000)); FileChannel fileChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); ) &#123; // 2.分配缓存 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (fileChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); // 3.发送数据到服务端 socketChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125;&#125; 12345678910111213141516171819202122232425@Testpublic void server() &#123; try ( // 1.获取通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); FileChannel fileChannel = FileChannel.open(Paths.get("c.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; // 2.绑定端口 serverSocketChannel.bind(new InetSocketAddress(10000)); // 3.获取客户端连接 SocketChannel socketChannel = serverSocketChannel.accept(); // 4.获取客户端的数据，保存到本地 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (socketChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); fileChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 非阻塞模式12345678910111213141516171819202122232425public class Client &#123; public static void main(String[] args) &#123; try ( // 打开通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("localhost", 8888)); ) &#123; // 设置非阻塞模式 socketChannel.configureBlocking(false); // 创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 发送数据 Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; String msg = scanner.next(); byteBuffer.put(msg.getBytes()); byteBuffer.flip(); socketChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Server &#123; public static void main(String[] args) &#123; try ( // 打开通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); ) &#123; // 绑定端口 serverSocketChannel.bind(new InetSocketAddress(8888)); //设置非阻塞模式 serverSocketChannel.configureBlocking(false); // 获取选择器 Selector selector = Selector.open(); // 注册连接事件 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (selector.select() &gt; 0) &#123; // 遍历注册事件，进行业务处理 Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); if (key.isAcceptable()) &#123; // 如果有客户端连接 SocketChannel socketChannel = serverSocketChannel.accept(); socketChannel.configureBlocking(false); // 注册读取事件，读取客户端发送的数据 socketChannel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; // 获取客户端的数据 SocketChannel socketChannel = (SocketChannel) key.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int len = 0; while ((len = socketChannel.read(byteBuffer)) &gt; 0) &#123; byteBuffer.flip(); System.out.println("[客户端]："+new String(byteBuffer.array(), 0, len)); byteBuffer.clear(); &#125; &#125; // 清除已处理的事件 it.remove(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Channel通道]]></title>
    <url>%2FChannel%E9%80%9A%E9%81%93%2F</url>
    <content type="text"><![CDATA[Channel通道的获取与原理 简介表示io源与目标打开的连接。Channel类似于传统的流，只不过Channel本身不能直接访问数据，Channel只能与Buffer进行交互。 Channel的主要实现类：FileChannel，SocketChannel，ServerSocketChannel，DatagramChannel 获取通道使用getChannel()方法1234567891011121314151617181920212223public void test1() throws FileNotFoundException &#123; try( FileInputStream fileInputStream = new FileInputStream("a.txt"); FileOutputStream fileOutputStream = new FileOutputStream("b.txt"); // 1.获取通道 FileChannel inChannel = fileInputStream.getChannel(); FileChannel outChannel = fileOutputStream.getChannel(); ) &#123; // 2.创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 3.将通道中的数据存入缓冲区 while (inChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); //切换到读数据模式 outChannel.write(byteBuffer); byteBuffer.clear(); //清空缓冲区 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 使用静态open()方法1234567891011121314151617public void test2() &#123; try( FileChannel inChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; // 内存映射文件 MappedByteBuffer inMappedByteBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMappedByteBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size()); byte[] dst = new byte[inMappedByteBuffer.limit()]; inMappedByteBuffer.get(dst); outMappedByteBuffer.put(dst); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 使用Files工具类中的静态方法 newByteChannel()1234567891011121314151617181920public void test3() &#123; try ( // 获取Channel，Files只能获取ByteChannel ByteChannel inChannel = Files.newByteChannel(Paths.get("a.txt"), StandardOpenOption.READ); ByteChannel outChannel = Files.newByteChannel(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; // 创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (inChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); outChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 通道之间的互相传输12345678910111213public void test4() &#123; try ( FileChannel inChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; //inChannel.transferTo(0, inChannel.size(), outChannel); // 或者 outChannel.transferFrom(inChannel, 0, inChannel.size()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 分散读取与聚集写入 12345678910111213141516171819public void test5() &#123; try ( FileChannel fileChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); ) &#123; // 分配缓冲区 ByteBuffer buffer1 = ByteBuffer.allocate(9); ByteBuffer buffer2 = ByteBuffer.allocate(6); ByteBuffer[] byteBuffers = &#123;buffer1, buffer2&#125;; // 分散读取 fileChannel.read(byteBuffers); for (ByteBuffer byteBuffer : byteBuffers) &#123; byteBuffer.flip(); System.out.println(byteBuffer + new String(byteBuffer.array())); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 123456789101112131415161718192021public void test6() &#123; try ( FileChannel inChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; ByteBuffer buffer1 = ByteBuffer.allocate(72); ByteBuffer buffer2 = ByteBuffer.allocate(72); ByteBuffer[] buffers = &#123;buffer1, buffer2&#125;; inChannel.read(buffers); for (ByteBuffer buffer : buffers) &#123; buffer.flip(); &#125; // 聚集写入 outChannel.write(buffers); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Buffer缓冲区]]></title>
    <url>%2FBuffer%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[NIO 中Buffer缓冲区介绍及基本操作 简介Buffer(缓冲区)，在Java NIO中负责数据的存取。缓冲区本质上就是数组，用于存储不同数据类型的数据。 根据数据类型不同(boolean除外)，提供了相应类型的缓冲区 ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 缓冲区可以通过allocate()获取缓冲区 12// 创建一个指定大小的缓冲区ByteBuffer byteBuffer = ByteBuffer.allocate(1024); 直接缓冲区与非直接缓冲区通过allocate()方式创建的缓冲区，称为非直接缓冲区，这种缓冲区是在jvm中创建的。 通过allocateDirect()创建的缓冲区，称为直接缓冲区，这种缓冲区是在物理内存中直接创建的。 使用allocateDirect()所需要的成本比allocate()要高，而且无法使用垃圾自动回收。 四个核心属性 capacity：容量，表示缓冲区中最大存储数据的容量，一旦声明不能改变 limit：界限，表示缓冲区中可以操作数据的大小。(limit后数据不能进行读写)。 position：位置，表示缓冲区中正在操作数据的位置。 mark：标记，表示当前position的位置，可以通过reset()恢复到mark的位置 四个属性的关系：0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity 常用操作allocate()：创建缓冲区 1234ByteBuffer byteBuffer = ByteBuffer.allocate(1024);System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //1024System.out.println("capacity: "+byteBuffer.capacity()); //1024 put()：向缓冲区中写数据 12345String name = "tom";byteBuffer.put(name.getBytes());System.out.println("position: "+byteBuffer.position()); //3System.out.println("limit: "+byteBuffer.limit()); //1024System.out.println("capacity: "+byteBuffer.capacity()); //1024 flip()：切换到读数据模式 1234byteBuffer.flip();System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //3System.out.println("capacity: "+byteBuffer.capacity()); //1024 get()：读取缓冲区中的数据 123456byte[] dst = new byte[byteBuffer.limit()];byteBuffer.get(dst);System.out.println("buffer中的数据："+new String(dst, 0, dst.length));System.out.println("position: "+byteBuffer.position()); //3System.out.println("limit: "+byteBuffer.limit()); //3System.out.println("capacity: "+byteBuffer.capacity()); //1024 rewind()：重新从头读取数据 1234byteBuffer.rewind();System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //3System.out.println("capacity: "+byteBuffer.capacity()); //1024 clear()：清除缓冲区，数据依然存在。只是位置信息被初始化 1234byteBuffer.clear();System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //1024System.out.println("capacity: "+byteBuffer.capacity()); //1024 mark()：标记position的位置 1234byteBuffer.put("jerry".getBytes());byteBuffer.mark(); //当position为5时，进行标记byteBuffer.put("tom".getBytes());System.out.println("position: "+byteBuffer.position()); //8 reset()：恢复mark标记的position的位置 12byteBuffer.reset();System.out.println("position: "+byteBuffer.position()); //5]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO 概述]]></title>
    <url>%2FJava-NIO-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Java NIO简介 Java NIO 简介Java NIO(New IO / Non Blocking IO)是从Java1.4 版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有相同的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO以更加高效的方式进行文件的读写操作。 NIO与IO的区别 IO NIO 面向流(Stream Oriented) 面向缓冲区(Buffer Oriented) 阻塞IO(Blocking IO) 非阻塞IO(Non Blocking IO) 选择器(Selectors) 通道和缓冲区Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到IO设备(如：文件、套接字)的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。 缓冲区是一个用于存放特定基本数据类型的容器。由java.nio包定义，所有的缓冲区都是Buffer抽象类的子类。缓冲区主要用来与通道进行交互，数据从通道读入缓冲区，从缓冲区写入通道。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些感悟]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[最近的一些感悟 &emsp;&emsp;有十天没有写过东西了，今天刚好周末，说静下心来写写东西吧，结果坐下来想了想，似乎并没有什么要写的。感觉这一周仿佛什么都没有做一样。再往深处想一想，一年仅仅52周，如果每周都是这个样子，那么一年也就是这个样子了。一年是这个样子，十年呢，二十年呢？细思极恐，一辈子碌碌无为恐怕就是这样的吧。 &emsp;&emsp;似乎我们身边的人都感觉时间是最不值钱的东西，我们可以整天待在家里抱着手机看一天的视频或者小说，仗着自己年轻，尽情挥霍着大把大把的时间。然后感叹一下，哎，今天又虚度了一天。结果第二天依然如此，日复一日，年复一年。 &emsp;&emsp;世间虽有很多的不公，但在时间上，是绝对公平的。每个人所拥有的时间都是完全一样的。人与人的区别就在于时间利用上的不同而体现出来的。有的人是重复昨天，而有的人是活在今天。勤学似春起之苗,不见其增,日有所长;辍学如磨刀之石,不见其损,日有所亏。 &emsp;&emsp;与君共勉。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>瞎写</tag>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型模式之简单工厂]]></title>
    <url>%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[简单工厂模式的介绍及写法 简单工厂模式提供一个创建对象实例的功能，而无需关心其具体的实现。被创建的实例类可以是接口，抽象类，也可以是具体的类。简单工厂并不在23中设计模式中，更多的时候是一种编程习惯。它通过接受不同的参数来返回不同的对象。 示例代码想象一个场景，你需要用笔写 一封信，有三种笔：铅笔，圆珠笔，中性笔，每种笔都有write()方法。 先定义笔接口 123public interface Pen &#123; void write(String words);&#125; 铅笔类 123456public class Pencil implements Pen &#123; @Override public void write(String words) &#123; System.out.println("使用铅笔写："+words); &#125;&#125; 圆珠笔类 123456public class BallpointPen implements Pen &#123; @Override public void write(String words) &#123; System.out.println("使用圆珠笔写："+words); &#125;&#125; 中性笔类 123456public class GelPen implements Pen &#123; @Override public void write(String words) &#123; System.out.println("使用中性笔写："+words); &#125;&#125; 下面是工厂类的具体实现 12345678910111213public class PenFactory &#123; public static Pen getPen(String penType) &#123; if ("pencil".equalsIgnoreCase(penType)) &#123; return new Pencil(); &#125; else if ("gelpen".equalsIgnoreCase(penType)) &#123; return new GelPen(); &#125; else if ("ballpointpen".equalsIgnoreCase(penType)) &#123; return new BallpointPen(); &#125; else &#123; return null; &#125; &#125;&#125; 这个工厂类根据不同的penType，new 不同的Pen对象。 在客户端调用 铅笔写 12Pen pencil = PenFactory.getPen("pencil");pencil.write("Hi tom!"); 圆珠笔写 12Pen ballpointPen = PenFactory.getPen("ballpointpen");ballpointPen.write("Hi tom!"); 中性笔写 12Pen gelPen = PenFactory.getPen("gelpen");gelpen.write("Hi tom!"); 客户端只需要从工厂取自己需要的产品就可以，不需要自己new，降低了耦合度。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>简单工厂</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型模式之单例模式]]></title>
    <url>%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式介绍与写法 什么是单例模式单例模式，顾名思义，单个实例的模式。保证一个类只有一个实例，并提供一个访问该实例的全局访问点。 为什么要有单例模式在某些场景下，某个类只允许一个实例。如操作系统的资源管理器，任务管理器，读取配置文件的类等。如果一个操作系统有多个资源管理器，那系统就乱套了。项目中读取配置文件的类如果有多个，则会浪费不必要的内存空间。 常见的五种单例模式的实现懒汉单例懒汉单例模式，只有当使用到单例对象时，才会进行实例化操作。 1234567891011121314151617181920212223242526272829303132333435363738public class Singleton1 implements Serializable&#123; /** * 懒汉单例，具体使用时才会实例化(懒加载) */ private static Singleton1 instance; /** * 私有化构造器，防止通过new创建对象 */ private Singleton1() &#123; //防止通过反射创建对象 if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; /** * 获取单例对象 * 延时加载，当使用对象时才实例化 * * @return */ public synchronized static Singleton1 getInstance() &#123; if (instance == null) &#123; instance = new Singleton1(); &#125; return instance; &#125; /** * 防止反序列化时创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125;&#125; 饿汉单例饿汉单例模式，类初始化时立即实例化对象。 12345678910111213141516171819202122232425public class Singleton2 implements Serializable &#123; /** * 饿汉单例模式，类初始化时创建对象 */ private static Singleton2 instance = new Singleton2(); private Singleton2() &#123; //防止反射创建单例对象 if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; public static Singleton2 getInstance() &#123; return instance; &#125; /** * 防止反序列化创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125; 双重检查锁式单例在jdk1.5之前，使用这种方式偶尔会有问题，不建议使用。 123456789101112131415161718192021222324252627282930313233public class Singleton3 &#123; private static volatile Singleton3 instance; private Singleton3() &#123; if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; /** * 双重检查锁单例 * @return */ public static Singleton3 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton3.class) &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; &#125; &#125; return instance; &#125; /** * 防止反序列化创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125;&#125; 静态内部类式单例线程安全，调用效率高，延时加载，推荐使用这种方式。 123456789101112131415161718192021222324252627282930public class Singleton4 implements Serializable &#123; /** * 创建静态内部类 */ private static class SingletonClassInstance &#123; private static final Singleton4 instance = new Singleton4(); &#125; /** * 私有化构造方法 */ private Singleton4() &#123; if (SingletonClassInstance.instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; public static Singleton4 getInstance() &#123; return SingletonClassInstance.instance; &#125; /** * 防止反序列化创建新对象 * * @return */ private Object readResolve() &#123; return SingletonClassInstance.instance; &#125;&#125; 枚举单例12345678910public enum Singleton5 &#123; INSTANCE; /** * 自定义操作 */ public void operation() &#123; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式概述]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[四人帮23种设计模式概述 什么是设计模式&emsp;&emsp;设计模式，是指在软件开发中，经过验证的，用于解决在特定环境下，重复出现的、特定问题的解决方案。通俗的说，就是解决特定问题的套路方法。 为什么要学设计模式 他山之石，可以攻玉。学习别人解决问题的思路，以后自己碰到了就可以很好的解决同样的问题。 提升逼格。让自己的代码更优雅，更有设计感。 如何学习设计模式 心态要稳，学习要狠。不要指望一步登天，心浮气躁。 理论与实践相结合。多写多思考，在实际开发中使用，然后再结合理论思考，然后再应用，再思考……如此循环，反复多次，直到达到对设计模式掌握的水平。 学习设计模式的三个层次鹦鹉学舌&emsp;&emsp;能够正确理解和掌握每个设计模式的基本知识，能够识别在什么场景下，出现了什么样的问题，采用何种方案解决它，并能够在实际的程序设计和开发中套用相应的设计模式。 照猫画虎&emsp;&emsp;能根据具体的实际情况，对设计模式进行适当的变形使用，能够确保正确使用设计模式，而不是生搬硬套。 学以致用&emsp;&emsp;真正的设计模式是没有模式。从本质上已经掌握了设计模式的精髓，并完全融入到了自己的思想中。在设计程序的时候，可以随意的，自然而然的运用。 上面基本都是废话，下面来点干货。 设计模式的六大原则开闭原则一个软件的实体(类、方法、模块等)，应该对扩展开放，对修改关闭。 依赖倒置原则高层模块不应该依赖底层模块，两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。 迪米特法则如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 单一职责原则一个类只做一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。 里氏替换原则接口或类出现的地方，他们的实现或者子类可以完全替换调他们。 接口隔离原则不要提供一个大的接口包含所有功能，要根据功能把这些接口分割，减少依赖。 设计模式分类创建型模式创建型模式有五种。 单例模式、工厂模式、建造者模式、原型模式、适配器模式。 结构型模式结构型模式有七种。 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为模式行为模式有十一种。 模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo上传图片]]></title>
    <url>%2FHexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[自己写的简单客户端，解决上传到云图床的痛点。 之前的做法&emsp;&emsp;陆陆续续也写了有七八篇博客了，其他的感觉都还不错，就是图片上传体验并不愉快。我用的腾讯云图床存储图片，但我所使用的markdown编辑器并不提供上传图片的插件，腾讯云也没有客户端，只有网页版，所以只能是打开腾讯云后台上传图片，然后将图片的访问地址粘贴到编辑器中，刚开始感觉也不算什么麻烦事，但时间一长，来来回回的切换，就感觉不是那么方便了。 没有枪，没有炮，自己造。 &emsp;&emsp;既然咱是程序员，那就应该干点程序员该干的事，没有怎么办？自己写一个！ 开始干&emsp;&emsp;其实这个需求很简单，把文件传到服务器，返回个访问地址就可以了。想明白需求，那就简单了。然而，需求是明确了，痛处也来了——我并不熟悉桌面程序的写法😱。虽说干开发也有两年多了，但都是开发web项目，并没有写过桌面程序。只是刚刚接触Java时，学过一点点，但两年时间了，早就忘得一干二净了。 不过这点小困难可难不倒咱，正好身边有本书，那就现学现卖喽。 说起这本书，从买下到现在应该也有差不多四年了，也就刚刚买下那段时间看了看，现在基本都在吃灰，实在惭愧b(￣▽￣)d 扯远了，说正事。反正是逮着书一顿猛看，算是稍微有点印象了。然后着手开始写，写着写着，有些地方忘了，又回头看书，如此反反复复多次后，总算是有些样子了。写完抬起头看看窗外，天都黑了。 鲁迅曾说过： 有些时候，人总是将问题看的很简单，但当你去做的时候，发现其实并不是那么回事。 好吧，这句话是我编的，写程序都写出哲理了，感觉也是萌萌哒😵。 总之，不管怎么样，东西总算是做出来了，下面介绍下我的处女作。 程序基本介绍 如你所见，这个就是程序的主界面，功能简洁明了，遵循极简主义设计😂。下面介绍下使用方法： 选择文件点击选择文件按钮，弹出文件选择框，选中文件。 返回界面后，显示待上传文件列表 图片是单选的，如果要选多张图片，需要选多次。 好吧，我知道这点不好，本来做成了多选的，但那个多选文件的框太丑，而且不能预览图片，所以最终选择了这种方式。 上传文件上传没什么好说的，直接点击上传就可以了。 当没有选择文件，点击上传时： 历史记录显示上传历史。 未上传过文件，点击历史记录时： 清除内容清除主页面所有的显示。 清除内容不会清除历史，只会清除显示的文字。历史记录是存储在文本中的。 最后如果你我瞎鼓捣出的这个小玩意感兴趣，我打包好放到百度云盘了，下载就可以用，如果需要源码，直接邮箱联系我，我会抽时间发过去的。 软件使用时，需要在配置文件中配置自己的腾讯云相关参数。 点击这里下载]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>上传图片</tag>
        <tag>云图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo写作样式简介]]></title>
    <url>%2FHexo%E5%86%99%E4%BD%9C%E6%A0%B7%E5%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[使用Hexo中自带的写作样式，丰富文章表现形式 note标签修改主题配置文件_config.yml 12345note: style: flat icons: true border_radius: 3 light_bg_offset: 0 default 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; primary 1&lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt; success 1&lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt; info 1&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt; warning 1&lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt; danger 1&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; tabs标签选项卡 1选项卡 2选项卡 3选项卡 1 选项卡 2 这是选项卡 3 上面的，3表示打开页面时，默认展示第三个选项卡 1234567891011&#123;% tabs 选项卡, 3 %&#125;&lt;!-- tab --&gt;**选项卡 1**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 3**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 图标 照相机 电池 hexo 使用的是fontawesome图标，直接引用就可以 121. &lt;i class="fa fa-camera"&gt;&lt;/i&gt; 照相机2. &lt;i class="fa fa-battery-4"&gt;&lt;/i&gt; 电池 按钮google一下 1&#123;% btn https://www.google.com, google一下, google fa-fw %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>写作样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用git]]></title>
    <url>%2FIntelliJ-IDEA-%E4%BD%BF%E7%94%A8git%2F</url>
    <content type="text"><![CDATA[介绍了IDEA中如何使用git IDEA中git的配置使用Ctrl+Alt+S打开设置 如图所示进行配置，配置完场后点击Test按钮，如果弹出版本号表示配置成功。 项目中使用gitgit检出项目 填写完地址后，点击Clone就可以检出项目了。 为项目添加git版本控制如图所示，为项目创建一个本地git版本库 选择当前项目文件夹，创建版本库 项目右键，将项目添加到版本控制中 提交项目到本地的仓库 填写提交说明，点击提交 连接到远程仓库 设置远程仓库位置 推送到远程仓库]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java String split的坑]]></title>
    <url>%2Fjava-String-split%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一个关于Java String split方法的坑 Java的String中，有一个方法split() 1public String[] split(String regex) 这个方法根据给定的正则表达式，去切分目标字符串，并返回切分后的结果。 简单的测试代码： 123456@Testpublic void test1() &#123; System.out.println(Arrays.toString("1,2".split(",")));&#125;// 输出结果：[1, 2] 上面的代码，输出结果完全符合预期。然而，当把代码做如下修改时： 123456@Testpublic void test2() &#123; System.out.println(Arrays.toString("1.2".split(".")));&#125;// 输出结果：[] 难道不应该输出 [1, 2]吗？ 其实问题就出在split的参数上，在Java中，有些特殊符号输入时，是必须要转义的 \。 将参数改为\\.，就能输出正确结果了 123456@Testpublic void test3() &#123; System.out.println(Arrays.toString("1.2".split("\\.")));&#125;// 输出结果：[1, 2]]]></content>
      <categories>
        <category>踩坑记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由拆装箱引起的性能问题]]></title>
    <url>%2F%E7%94%B1%E6%8B%86%E8%A3%85%E7%AE%B1%E5%BC%95%E8%B5%B7%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Integer.valueOf与Integer.parseInt引发的性能问题 问题代码1int a = Integer.valueOf(request.getParameter("baseProjectId")) 这段代码看上去没什么问题，但其实会有性能上的浪费，Integer.valueOf()的部分源码： 12345678910public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10)); // 注意parseInt这句&#125;public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 由代码可以看出，Integer.valueOf() 先调用parseInt()解析字符串，然后再调用方法，将int转换为Integer对象，然后返回Integer对象。结合上面的问题代码，整个类型转换流程为： 1String --&gt; int --&gt; Integer --&gt; int 在此过程中，不仅创建了一个临时对象，浪费内存，而且进行了一次拆装箱操作，浪费了性能。 更改建议直接将Integer.valueOf()改为Integer.parseInt() 1int a = Integer.parseInt(request.getParameter("baseProjectId"))]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解防盗链]]></title>
    <url>%2F%E7%A0%B4%E8%A7%A3%E9%98%B2%E7%9B%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[用简单粗暴的方式破解防盗链 什么是盗链简单来说，有两个网站，A和B。A网站有一张图片 1&lt;img src="http://xxx/a.png" /&gt; B网站看到了这张图片，他不下载，直接将图片的地址放到了自己的服务器上。那么当用户访问B站点时，实际却跑的是A站点的流量和服务，从而不劳而获，这就是盗链。 referrer为了解决这种事情，HTTP协议规定：浏览器在加载非本站资源时，会增加如下请求头： 1Referer: http://localhost:8080/temp/b.html 这个Referer标签是告诉请求者，引用这个资源的站点是谁 防盗链原理一般的站点，会根据Referer来进行防盗链工作，当请求头存在Referer时，即为非法引用，此时服务器拒绝服务，从而达到防盗链的目的。具体的实现有很多种，此处不细讲了，可自行Google。 破解防盗链了解了防盗链的基本原理后，破解就简单多了。只要想办法在请求的时候取消请求头中的Referer就可以了。这里破解也有好多种办法，可以使用nginx反向代理，或者使用iframe等等。这里介绍一种我认为相对来说最简单的办法： 1&lt;meta name="referrer" content="never"&gt; 只要在html中加入上面的meta标签，就可以破解简单的防盗链了。这个meta标签的意思是告诉浏览器，请求时不用包含referer相关的信息，从而达到破解防盗链的目的。 referer与referrer有人觉得很奇怪，浏览器中的请求头是referer，怎么标签里的是referrer，其实标签中的referrer才是正确的单词，据说是当时HTTP协议的制定者将单词拼错，大家就将错就错的使用了。具体可看维基百科的 HTTP来源地址 词条]]></content>
      <categories>
        <category>奇淫巧技</category>
      </categories>
      <tags>
        <tag>奇淫巧技</tag>
        <tag>防盗链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建git服务器]]></title>
    <url>%2F%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本地搭建git服务器 前言&emsp;&emsp;git可以说是目前使用最广泛的版本控制系统了，GitHub是基于git的免费的代码托管网站，有人说，既然都是免费的了，直接用不就好了吗，干嘛还要费劲自己搭建一个服务。我想说的是，GitHub虽然是免费的，但是有一点很重要，那就是私有性。公司内部的项目通常都是要保密的。虽然GitHub可以选择仓库私有，但那是要收费的。综上所述，还是在自己私有的服务器上搭建git服务比较合适。 &emsp;&emsp;本次演示使用VMware虚拟机，系统镜像CentOS 6.9 x64，root账户进行安装操作。 正文开始安装git使用yum查询当前是否有可安装的git版本 1[root@hadoop02 home]# yum info git 使用yum安装git 1[root@hadoop03 ~]# yum install -y git 检查是否安装成功 12[root@hadoop03 ~]# git versiongit version 1.7.1 创建git运行用户1[root@hadoop03 ~]# adduser git 在当前Linux系统中创建了一个新的用户git。 执行完以上命令后，会在/home生成一个git文件夹。我们cd到home目录查看一下 123[root@hadoop03 git]# cd /home/git[root@hadoop03 git]# ls -a. .. .bash_logout .bash_profile .bashrc .gnome2 .mozilla 禁止git用户shell登录创建git用户是为了访问服务器的git仓库，为了安全起见，将git用户禁止shell登录。 1[root@hadoop02 gitrepo]# vi /etc/passwd 找到类似下面的一句 1git:x:501:501::/home/git:/bin/bash 将其改为 1git:x:501:501::/home/git:/usr/bin/git-shell 保存即可 创建ssh证书登录在/home/git文件夹下，创建一个新文件夹.ssh，并新建一个文件authorized_keys，这个authorized_keys文件用来存放我们的git公钥。 12345[root@hadoop03 git]# mkdir .ssh[root@hadoop03 git]# cd .ssh[root@hadoop03 .ssh]# touch authorized_keys[root@hadoop03 .ssh]# lsauthorized_keys 收集团队中其他人的git公钥，复制后添加到authorized_keys文件中。git公钥一般存放在C:\Users\xxx\.ssh\id_rsa.pub中。如果你的电脑上没有，需要安装git客户端，并生成git公钥。关于此部分，我的另一篇博客使用GitHub-Pages-Hexo-搭建博客中有所介绍，此处不再细讲。 1[root@hadoop03 git]# vim authorized_keys 粘贴公钥后，保存即可。 注意：粘贴公钥时，注意空格。公钥一行一个。 初始化git仓库创建一个仓库目录，我放在/home/gitrepo下面 123[root@hadoop03 home]# mkdir gitrepo[root@hadoop03 home]# lsgit gitrepo 初始化git仓库，假设项目名叫test 123[root@hadoop03 home]# cd gitrepo/[root@hadoop03 gitrepo]# git init --bare test.gitInitialized empty Git repository in /home/gitrepo/test.git/ 执行完命令后，会在gitrepo下生成test.git目录 12[root@hadoop03 gitrepo]# lstest.git 修改仓库的归属权限，否则无法访问git仓库 1[root@hadoop02 gitrepo]# chown -R git:git test.git/ 至此，git服务器搭建完成。 克隆远程仓库1234λ git clone git@192.168.213.130:/home/gitrepo/test.gitCloning into 'test'...key_load_public: invalid formatwarning: You appear to have cloned an empty repository. 接下来就尽情使用git吧。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub Pages + Hexo 搭建博客]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用Github Pages + Hexo 自建博客的详细流程。包括创建GitHub账号，创建仓库，设置git客户端连接，ssh公钥，安装配置Hexo并部署，设置Hexo next主题，自定义域名。 折腾了近一个星期，终于将博客搭建成功了，现在将具体的过程写出来，以帮助需要自建博客的人。 GitHub部分注册GitHub账号要使用GitHub Pages，需要先注册GitHub账号，注册链接 注册流程就不细说了，相信大家都会注册的。 注册完成后，需要邮箱激活，请进入自己的注册邮箱，完成激活即可。 创建Git仓库Git repository(仓库) 用于存放博客内容 上面的按钮随便点击一个都可以跳转到创建仓库页面 私有仓库是收费的，公共仓库是免费的，这个根据情况自己选择即可。 仓库设置仓库创建成功后，进入仓库主页 点击进入仓库设置 如果创建时仓库名字是 xxx.github.io，则以上的选项默认是选中的。 至此，创建仓库就完成了，此时打开浏览器，输入 xxx(自己的仓库名).github.io就能访问自己的主页了。 安装Git客户端仓库创建完成后，需要安装Git客户端与Git仓库进行连接，方便我们在本地提交博客。 根据自己的操作系统，下载git客户端 ，完成安装。 设置git环境变量打开git的安装目录，并复制安装路径。 桌面上找到我的电脑 – &gt; 右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 –&gt; 系统变量 –&gt; Path 新建变量值，将刚刚复制的路径填进去，并在末尾加上\cmd，保存即可 测试环境变量是否配置成功，打开命令行输入 1git version 输出版本号，表示配置成功。 设置用户名和邮箱鼠标点击右键，选择Git GUI Here，打开git bash客户端 12git config --global user.name "zhangsan"git config --global user.email "zhangsan@sina.com" 生成ssh密钥1ssh-keygen -t rsa -C "zhangsan@sina.com" 连续回车即可。 设置GitHub公钥打开目录C:\Users\你自己的用户名\.ssh下，会有两个文件 id_rsa(私钥) id_rsa.pub(公钥) ，使用文本编辑器打开id_rsa.pub，复制里面的内容，登录GitHub，进入个人设置中心。 开始设置ssh 新建ssh key 填入公钥 点击 Add SSH key就可以了。 在本地测试连接 1ssh -T git@github.com 当输出以下内容时，表示连接成功。 Hexo部分安装nodejs根据自己的操作系统平台，下载nodejs，并安装。 nodejs环境变量安装好后，会自己添加到环境变量中，一般不需设置。 设置node环境变量和git环境变量类似，请参考git环境变量的配置。 注意：此处编辑变量值时，不需要在后面加\cmd，直接复制路径即可。 配置完成后，命令行输入 1node --version 输出版本号，表示配置成功。 安装Hexo使用npm安装Hexo，npm是nodejs自带的包依赖管理工具，类似于Centos中的yum。 1npm install -g hexo-cli 强烈建议浏览 Hexo官方文档，写的非常详细。 初始化博客123hexo init 自定义文件夹cd 自定义文件夹npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml #博客的全局配置文件├── package.json #包含了应用程序的信息├── scaffolds #模板文件夹├── source #用户资源文件夹| ├── _drafts #草稿箱| └── _posts #写的文章放到这里└── themes #主题文件夹 _config.yml文件详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo #网站标题subtitle: #网站副标题description: #网站描述keywords: #关键字author: John Doe #网站作者language: #网站所使用的语言 中文使用 zh-Hans 防止乱码timezone: #网站时区 Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com #网址root: / #网站根目录permalink: :year/:month/:day/:title/ #文章的 永久链接 格式permalink_defaults: #永久链接中各部分的默认值# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 # http://yoursite.com/blog 并把 root 设为 /blog/。# Directorysource_dir: source #资源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 # Writingnew_post_name: :title.md #新文章的文件名称default_layout: post #预设布局titlecase: false #把标题转换为 title caseexternal_link: true #在新标签中打开链接filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址future: true #显示未来的文章highlight: #代码块的设置 enable: true #是否开启代码块支持 line_number: true #显示行号 auto_detect: false tab_replace: #设置用什么字符替代Tab，如tab_replace: aaa，在代码中将输入tab的地方替换为aaa # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式# Pagination## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章条数pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape #当前所使用的主题名# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #部署部分设置 type: #部署类型 根据需要更改配置文件，进行个性化配置 启动Hexo服务初始化完成后，就可以启动Hexo服务了，进入博客目录，执行以下命令，即可启动服务 12hexo g #生成静态文件hexo s #启动hexo服务 打开浏览器，输入http://localhost:4000/ 配置了这么长时间，终于看到点效果了，有没有很激动O(∩_∩)O Hexo基本命令1234567hexo generate #生成静态文件，可以简写为 hexo ghexo clean #清除生成的静态文件hexo server #启动hexo服务进行预览，可以简写为 hexo shexo deploy #部署到服务器，可以简写为hexo dhexo new "文件名" #创建新文章hexo new draft "文件名" #创建草稿箱文章hexo new page "页面名" #创建新页面 配置部署到GitHub更改_config.yml配置文件的deploy部分。 1234deploy: type: git repo: https://github.com/xxx/xxx.github.io.git branch: master #部署的分支 或者 1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master #部署的分支 部署到GitHub1hexo d 自定义域名首先要有注册好的域名，没有的话，可以先去注册。域名的注册这里不多介绍了，资料很多，大家可以自己选择域名注册商进行注册。 CNAME类型解析注册好域名后，在博客的资源文件夹source下创建一个文件，CNAME，注意，这个文件没有后缀。使用文本编辑器打开，填入自己的域名，并保存。 登录自己的域名解析后台，添加一条解析记录。记录类型选择CNAME，记录值填入之前GItHub分配的访问路径xxx.github.io，保存后就可以用自己的域名访问博客了。 注意：CNAME文件一定要放在source路径下，否则下次部署的时候，CNAME就被删除了。 A类型解析在自己的域名解析后台添加一条解析记录，记录类型选择A，记录值填写自己项目访问路径的IP地址。如果不清楚IP地址，可以通过ping 项目访问路径的方式获得，然后填入记录值中即可。 Hexo更换next主题安装next主题建议根据官方文档安装，遇到不明白的地方再找别的资料参考 next官方文档 Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。 cd 到你的博客路径下，使用git下载主题文件 1git clone https://github.com/iissnan/hexo-theme-next themes/next 修改博客配置文件_config.yml，将theme: landscape修改为theme: next 启动服务即可。 上面的界面是我美化后的效果，图片仅供参考。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>自建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要写博客]]></title>
    <url>%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[关于写博客，自建博客的一些个人看法 写博客的原因记录解决问题的步骤，方便查阅&emsp;&emsp;首先作为程序员来讲，工作中都会遇到很多自己解决不了的问题。很多时候自己都是习惯去Google，或者各个博客看别人的解决办法，然后尝试解决问题。在这个过程中，发现很多人写的都是错误的，经常是按照A写的做，做完发现不对，又按照B写的做，发现又不对…… 最后终于将问题解决了，过一段时间遇到相同的问题，却又想不起来当初是怎么解决的。有了博客，就可以记录查阅了。 知识，只有自己总结后，才是自己的&emsp;&emsp;俗话说眼过千遍，不如手过一遍。这句话在编程界尤为适用。某个知识点，看着别人写的，感觉自己都会了，等到自己动手写的时候，脑子里空空如也，半棍子打不出一个屁来。有了博客，在写博客的时候，就会强迫自己将知识点深入理解，也算是知识梳理的过程吧。 提高写作水平&emsp;&emsp;其实自己一直有一个写作的梦想，当年读高中时，还曾经写过一本侦探小说🤣。写博客，可以练习练习语言组织能力，天天写代码，有时候连话都说不太清了。 自建博客的原因不信任第三方博客&emsp;&emsp;网络世界错综复杂，各个博客平台此消彼长。说不定到那一天，自己所在的平台就消失了，到时候当初自己辛辛苦苦写的东西也就随之消失。这是一件非常痛心的事情。 自己的地盘，可以尽情折腾&emsp;&emsp;大概程序员都喜欢自己折腾吧。自建博客，所有的东西都是自己说了算，感觉非常自由。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
