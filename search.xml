<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[创建型模式之单例模式]]></title>
    <url>%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式介绍与写法 什么是单例模式单例模式，顾名思义，单个实例的模式。保证一个类只有一个实例，并提供一个访问该实例的全局访问点。 为什么要有单例模式在某些场景下，某个类只允许一个实例。如操作系统的资源管理器，任务管理器，读取配置文件的类等。如果一个操作系统有多个资源管理器，那系统就乱套了。项目中读取配置文件的类如果有多个，则会浪费不必要的内存空间。 常见的五种单例模式的实现懒汉单例懒汉单例模式，只有当使用到单例对象时，才会进行实例化操作。 1234567891011121314151617181920212223242526272829303132333435363738public class Singleton1 implements Serializable&#123; /** * 懒汉单例，具体使用时才会实例化(懒加载) */ private static Singleton1 instance; /** * 私有化构造器，防止通过new创建对象 */ private Singleton1() &#123; //防止通过反射创建对象 if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; /** * 获取单例对象 * 延时加载，当使用对象时才实例化 * * @return */ public synchronized static Singleton1 getInstance() &#123; if (instance == null) &#123; instance = new Singleton1(); &#125; return instance; &#125; /** * 防止反序列化时创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125;&#125; 饿汉单例饿汉单例模式，类初始化时立即实例化对象。 12345678910111213141516171819202122232425public class Singleton2 implements Serializable &#123; /** * 饿汉单例模式，类初始化时创建对象 */ private static Singleton2 instance = new Singleton2(); private Singleton2() &#123; //防止反射创建单例对象 if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; public static Singleton2 getInstance() &#123; return instance; &#125; /** * 防止反序列化创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125; 双重检查锁式单例在jdk1.5之前，使用这种方式偶尔会有问题，不建议使用。 123456789101112131415161718192021222324252627282930313233public class Singleton3 &#123; private static volatile Singleton3 instance; private Singleton3() &#123; if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; /** * 双重检查锁单例 * @return */ public static Singleton3 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton3.class) &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; &#125; &#125; return instance; &#125; /** * 防止反序列化创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125;&#125; 静态内部类式单例线程安全，调用效率高，延时加载，推荐使用这种方式。 12345678910111213141516171819202122232425262728293031public class Singleton4 implements Serializable &#123; /** * 创建静态内部类 */ private static class SingletonClassInstance &#123; private static final Singleton4 instance = new Singleton4(); &#125; /** * 私有化构造方法 */ private Singleton4() &#123; if (SingletonClassInstance.instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; public static Singleton4 getInstance() &#123; return SingletonClassInstance.instance; &#125; /** * 防止反序列化创建新对象 * * @return */ private Object readResolve() &#123; return SingletonClassInstance.instance; &#125;&#125; 枚举单例12345678910public enum Singleton5 &#123; INSTANCE; /** * 自定义操作 */ public void operation() &#123; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式概述]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[四人帮23种设计模式概述 什么是设计模式&emsp;&emsp;设计模式，是指在软件开发中，经过验证的，用于解决在特定环境下，重复出现的、特定问题的解决方案。通俗的说，就是解决特定问题的套路方法。 为什么要学设计模式 他山之石，可以攻玉。学习别人解决问题的思路，以后自己碰到了就可以很好的解决同样的问题。 提升逼格。让自己的代码更优雅，更有设计感。 如何学习设计模式 心态要稳，学习要狠。不要指望一步登天，心浮气躁。 理论与实践相结合。多写多思考，在实际开发中使用，然后再结合理论思考，然后再应用，再思考……如此循环，反复多次，直到达到对设计模式掌握的水平。 学习设计模式的三个层次鹦鹉学舌&emsp;&emsp;能够正确理解和掌握每个设计模式的基本知识，能够识别在什么场景下，出现了什么样的问题，采用何种方案解决它，并能够在实际的程序设计和开发中套用相应的设计模式。 照猫画虎&emsp;&emsp;能根据具体的实际情况，对设计模式进行适当的变形使用，能够确保正确使用设计模式，而不是生搬硬套。 学以致用&emsp;&emsp;真正的设计模式是没有模式。从本质上已经掌握了设计模式的精髓，并完全融入到了自己的思想中。在设计程序的时候，可以随意的，自然而然的运用。 上面基本都是废话，下面来点干货。 设计模式的六大原则开闭原则一个软件的实体(类、方法、模块等)，应该对扩展开放，对修改关闭。 依赖倒置原则高层模块不应该依赖底层模块，两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。 迪米特法则如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 单一职责原则一个类只做一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。 里氏替换原则接口或类出现的地方，他们的实现或者子类可以完全替换调他们。 接口隔离原则不要提供一个大的接口包含所有功能，要根据功能把这些接口分割，减少依赖。 设计模式分类创建型模式创建型模式有五种。 单例模式、工厂模式、建造者模式、原型模式、适配器模式。 结构型模式结构型模式有七种。 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为模式行为模式有十一种。 模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo上传图片]]></title>
    <url>%2FHexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[自己写的简单客户端，解决上传到云图床的痛点。 之前的做法&emsp;&emsp;陆陆续续也写了有七八篇博客了，其他的感觉都还不错，就是图片上传体验并不愉快。我用的腾讯云图床存储图片，但我所使用的markdown编辑器并不提供上传图片的插件，腾讯云也没有客户端，只有网页版，所以只能是打开腾讯云后台上传图片，然后将图片的访问地址粘贴到编辑器中，刚开始感觉也不算什么麻烦事，但时间一长，来来回回的切换，就感觉不是那么方便了。 没有枪，没有炮，自己造。 &emsp;&emsp;既然咱是程序员，那就应该干点程序员该干的事，没有怎么办？自己写一个！ 开始干&emsp;&emsp;其实这个需求很简单，把文件传到服务器，返回个访问地址就可以了。想明白需求，那就简单了。然而，需求是明确了，痛处也来了——我并不熟悉桌面程序的写法😱。虽说干开发也有两年多了，但都是开发web项目，并没有写过桌面程序。只是刚刚接触Java时，学过一点点，但两年时间了，早就忘得一干二净了。 不过这点小困难可难不倒咱，正好身边有本书，那就现学现卖喽。 说起这本书，从买下到现在应该也有差不多四年了，也就刚刚买下那段时间看了看，现在基本都在吃灰，实在惭愧b(￣▽￣)d 扯远了，说正事。反正是逮着书一顿猛看，算是稍微有点印象了。然后着手开始写，写着写着，有些地方忘了，又回头看书，如此反反复复多次后，总算是有些样子了。写完抬起头看看窗外，天都黑了。 鲁迅曾说过： 有些时候，人总是将问题看的很简单，但当你去做的时候，发现其实并不是那么回事。 好吧，这句话是我编的，写程序都写出哲理了，感觉也是萌萌哒😵。 总之，不管怎么样，东西总算是做出来了，下面介绍下我的处女作。 程序基本介绍 如你所见，这个就是程序的主界面，功能简洁明了，遵循极简主义设计😂。下面介绍下使用方法： 选择文件点击选择文件按钮，弹出文件选择框，选中文件。 返回界面后，显示待上传文件列表 图片是单选的，如果要选多张图片，需要选多次。 好吧，我知道这点不好，本来做成了多选的，但那个多选文件的框太丑，而且不能预览图片，所以最终选择了这种方式。 上传文件上传没什么好说的，直接点击上传就可以了。 当没有选择文件，点击上传时： 历史记录显示上传历史。 未上传过文件，点击历史记录时： 清除内容清除主页面所有的显示。 清除内容不会清除历史，只会清除显示的文字。历史记录是存储在文本中的。 最后如果你我瞎鼓捣出的这个小玩意感兴趣，我打包好放到百度云盘了，下载就可以用，如果需要源码，直接邮箱联系我，我会抽时间发过去的。 软件使用时，需要在配置文件中配置自己的腾讯云相关参数。 点击这里下载]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>上传图片</tag>
        <tag>云图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo写作样式简介]]></title>
    <url>%2FHexo%E5%86%99%E4%BD%9C%E6%A0%B7%E5%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[使用Hexo中自带的写作样式，丰富文章表现形式 note标签修改主题配置文件_config.yml 12345note: style: flat icons: true border_radius: 3 light_bg_offset: 0 default 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; primary 1&lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt; success 1&lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt; info 1&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt; warning 1&lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt; danger 1&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; tabs标签选项卡 1选项卡 2选项卡 3选项卡 1 选项卡 2 这是选项卡 3 上面的，3表示打开页面时，默认展示第三个选项卡 1234567891011&#123;% tabs 选项卡, 3 %&#125;&lt;!-- tab --&gt;**选项卡 1**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 3**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 图标 照相机 电池 hexo 使用的是fontawesome图标，直接引用就可以 121. &lt;i class="fa fa-camera"&gt;&lt;/i&gt; 照相机2. &lt;i class="fa fa-battery-4"&gt;&lt;/i&gt; 电池 按钮google一下 1&#123;% btn https://www.google.com, google一下, google fa-fw %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>写作样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用git]]></title>
    <url>%2FIntelliJ-IDEA-%E4%BD%BF%E7%94%A8git%2F</url>
    <content type="text"><![CDATA[介绍了IDEA中如何使用git IDEA中git的配置使用Ctrl+Alt+S打开设置 如图所示进行配置，配置完场后点击Test按钮，如果弹出版本号表示配置成功。 项目中使用gitgit检出项目 填写完地址后，点击Clone就可以检出项目了。 为项目添加git版本控制如图所示，为项目创建一个本地git版本库 选择当前项目文件夹，创建版本库 项目右键，将项目添加到版本控制中 提交项目到本地的仓库 填写提交说明，点击提交 连接到远程仓库 设置远程仓库位置 推送到远程仓库]]></content>
      <categories>
        <category>编程工具</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java String split的坑]]></title>
    <url>%2Fjava-String-split%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一个关于Java String split方法的坑 Java的String中，有一个方法split() 1public String[] split(String regex) 这个方法根据给定的正则表达式，去切分目标字符串，并返回切分后的结果。 简单的测试代码： 123456@Testpublic void test1() &#123; System.out.println(Arrays.toString("1,2".split(",")));&#125;// 输出结果：[1, 2] 上面的代码，输出结果完全符合预期。然而，当把代码做如下修改时： 123456@Testpublic void test2() &#123; System.out.println(Arrays.toString("1.2".split(".")));&#125;// 输出结果：[] 难道不应该输出 [1, 2]吗？ 其实问题就出在split的参数上，在Java中，有些特殊符号输入时，是必须要转义的 \。 将参数改为\\.，就能输出正确结果了 123456@Testpublic void test3() &#123; System.out.println(Arrays.toString("1.2".split("\\.")));&#125;// 输出结果：[1, 2]]]></content>
      <categories>
        <category>踩坑记</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由拆装箱引起的性能问题]]></title>
    <url>%2F%E7%94%B1%E6%8B%86%E8%A3%85%E7%AE%B1%E5%BC%95%E8%B5%B7%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Integer.valueOf与Integer.parseInt引发的性能问题 问题代码1int a = Integer.valueOf(request.getParameter("baseProjectId")) 这段代码看上去没什么问题，但其实会有性能上的浪费，Integer.valueOf()的部分源码： 12345678910public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10)); // 注意parseInt这句&#125;public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 由代码可以看出，Integer.valueOf() 先调用parseInt()解析字符串，然后再调用方法，将int转换为Integer对象，然后返回Integer对象。结合上面的问题代码，整个类型转换流程为： 1String --&gt; int --&gt; Integer --&gt; int 在此过程中，不仅创建了一个临时对象，浪费内存，而且进行了一次拆装箱操作，浪费了性能。 更改建议直接将Integer.valueOf()改为Integer.parseInt() 1int a = Integer.parseInt(request.getParameter("baseProjectId"))]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解防盗链]]></title>
    <url>%2F%E7%A0%B4%E8%A7%A3%E9%98%B2%E7%9B%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[用简单粗暴的方式破解防盗链 什么是盗链简单来说，有两个网站，A和B。A网站有一张图片 1&lt;img src="http://xxx/a.png" /&gt; B网站看到了这张图片，他不下载，直接将图片的地址放到了自己的服务器上。那么当用户访问B站点时，实际却跑的是A站点的流量和服务，从而不劳而获，这就是盗链。 referrer为了解决这种事情，HTTP协议规定：浏览器在加载非本站资源时，会增加如下请求头： 1Referer: http://localhost:8080/temp/b.html 这个Referer标签是告诉请求者，引用这个资源的站点是谁 防盗链原理一般的站点，会根据Referer来进行防盗链工作，当请求头存在Referer时，即为非法引用，此时服务器拒绝服务，从而达到防盗链的目的。具体的实现有很多种，此处不细讲了，可自行Google。 破解防盗链了解了防盗链的基本原理后，破解就简单多了。只要想办法在请求的时候取消请求头中的Referer就可以了。这里破解也有好多种办法，可以使用nginx反向代理，或者使用iframe等等。这里介绍一种我认为相对来说最简单的办法： 1&lt;meta name="referrer" content="never"&gt; 只要在html中加入上面的meta标签，就可以破解简单的防盗链了。这个meta标签的意思是告诉浏览器，请求时不用包含referer相关的信息，从而达到破解防盗链的目的。 referer与referrer有人觉得很奇怪，浏览器中的请求头是referer，怎么标签里的是referrer，其实标签中的referrer才是正确的单词，据说是当时HTTP协议的制定者将单词拼错，大家就将错就错的使用了。具体可看维基百科的 HTTP来源地址 词条]]></content>
      <categories>
        <category>奇淫巧技</category>
      </categories>
      <tags>
        <tag>奇淫巧技</tag>
        <tag>防盗链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建git服务器]]></title>
    <url>%2F%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本地搭建git服务器 前言&emsp;&emsp;git可以说是目前使用最广泛的版本控制系统了，GitHub是基于git的免费的代码托管网站，有人说，既然都是免费的了，直接用不就好了吗，干嘛还要费劲自己搭建一个服务。我想说的是，GitHub虽然是免费的，但是有一点很重要，那就是私有性。公司内部的项目通常都是要保密的。虽然GitHub可以选择仓库私有，但那是要收费的。综上所述，还是在自己私有的服务器上搭建git服务比较合适。 &emsp;&emsp;本次演示使用VMware虚拟机，系统镜像CentOS 6.9 x64，root账户进行安装操作。 正文开始安装git使用yum查询当前是否有可安装的git版本 1[root@hadoop02 home]# yum info git 使用yum安装git 1[root@hadoop03 ~]# yum install -y git 检查是否安装成功 12[root@hadoop03 ~]# git versiongit version 1.7.1 创建git运行用户1[root@hadoop03 ~]# adduser git 在当前Linux系统中创建了一个新的用户git。 执行完以上命令后，会在/home生成一个git文件夹。我们cd到home目录查看一下 123[root@hadoop03 git]# cd /home/git[root@hadoop03 git]# ls -a. .. .bash_logout .bash_profile .bashrc .gnome2 .mozilla 禁止git用户shell登录创建git用户是为了访问服务器的git仓库，为了安全起见，将git用户禁止shell登录。 1[root@hadoop02 gitrepo]# vi /etc/passwd 找到类似下面的一句 1git:x:501:501::/home/git:/bin/bash 将其改为 1git:x:501:501::/home/git:/usr/bin/git-shell 保存即可 创建ssh证书登录在/home/git文件夹下，创建一个新文件夹.ssh，并新建一个文件authorized_keys，这个authorized_keys文件用来存放我们的git公钥。 12345[root@hadoop03 git]# mkdir .ssh[root@hadoop03 git]# cd .ssh[root@hadoop03 .ssh]# touch authorized_keys[root@hadoop03 .ssh]# lsauthorized_keys 收集团队中其他人的git公钥，复制后添加到authorized_keys文件中。git公钥一般存放在C:\Users\xxx\.ssh\id_rsa.pub中。如果你的电脑上没有，需要安装git客户端，并生成git公钥。关于此部分，我的另一篇博客使用GitHub-Pages-Hexo-搭建博客中有所介绍，此处不再细讲。 1[root@hadoop03 git]# vim authorized_keys 粘贴公钥后，保存即可。 注意：粘贴公钥时，注意空格。公钥一行一个。 初始化git仓库创建一个仓库目录，我放在/home/gitrepo下面 123[root@hadoop03 home]# mkdir gitrepo[root@hadoop03 home]# lsgit gitrepo 初始化git仓库，假设项目名叫test 123[root@hadoop03 home]# cd gitrepo/[root@hadoop03 gitrepo]# git init --bare test.gitInitialized empty Git repository in /home/gitrepo/test.git/ 执行完命令后，会在gitrepo下生成test.git目录 12[root@hadoop03 gitrepo]# lstest.git 修改仓库的归属权限，否则无法访问git仓库 1[root@hadoop02 gitrepo]# chown -R git:git test.git/ 至此，git服务器搭建完成。 克隆远程仓库1234λ git clone git@192.168.213.130:/home/gitrepo/test.gitCloning into 'test'...key_load_public: invalid formatwarning: You appear to have cloned an empty repository. 接下来就尽情使用git吧。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub Pages + Hexo 搭建博客]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用Github Pages + Hexo 自建博客的详细流程。包括创建GitHub账号，创建仓库，设置git客户端连接，ssh公钥，安装配置Hexo并部署，设置Hexo next主题，自定义域名。 折腾了近一个星期，终于将博客搭建成功了，现在将具体的过程写出来，以帮助需要自建博客的人。 GitHub部分注册GitHub账号要使用GitHub Pages，需要先注册GitHub账号，注册链接 注册流程就不细说了，相信大家都会注册的。 注册完成后，需要邮箱激活，请进入自己的注册邮箱，完成激活即可。 创建Git仓库Git repository(仓库) 用于存放博客内容 上面的按钮随便点击一个都可以跳转到创建仓库页面 私有仓库是收费的，公共仓库是免费的，这个根据情况自己选择即可。 仓库设置仓库创建成功后，进入仓库主页 点击进入仓库设置 如果创建时仓库名字是 xxx.github.io，则以上的选项默认是选中的。 至此，创建仓库就完成了，此时打开浏览器，输入 xxx(自己的仓库名).github.io就能访问自己的主页了。 安装Git客户端仓库创建完成后，需要安装Git客户端与Git仓库进行连接，方便我们在本地提交博客。 根据自己的操作系统，下载git客户端 ，完成安装。 设置git环境变量打开git的安装目录，并复制安装路径。 桌面上找到我的电脑 – &gt; 右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 –&gt; 系统变量 –&gt; Path 新建变量值，将刚刚复制的路径填进去，并在末尾加上\cmd，保存即可 测试环境变量是否配置成功，打开命令行输入 1git version 输出版本号，表示配置成功。 设置用户名和邮箱鼠标点击右键，选择Git GUI Here，打开git bash客户端 12git config --global user.name "zhangsan"git config --global user.email "zhangsan@sina.com" 生成ssh密钥1ssh-keygen -t rsa -C "zhangsan@sina.com" 连续回车即可。 设置GitHub公钥打开目录C:\Users\你自己的用户名\.ssh下，会有两个文件 id_rsa(私钥) id_rsa.pub(公钥) ，使用文本编辑器打开id_rsa.pub，复制里面的内容，登录GitHub，进入个人设置中心。 开始设置ssh 新建ssh key 填入公钥 点击 Add SSH key就可以了。 在本地测试连接 1ssh -T git@github.com 当输出以下内容时，表示连接成功。 Hexo部分安装nodejs根据自己的操作系统平台，下载nodejs，并安装。 nodejs环境变量安装好后，会自己添加到环境变量中，一般不需设置。 设置node环境变量和git环境变量类似，请参考git环境变量的配置。 注意：此处编辑变量值时，不需要在后面加\cmd，直接复制路径即可。 配置完成后，命令行输入 1node --version 输出版本号，表示配置成功。 安装Hexo使用npm安装Hexo，npm是nodejs自带的包依赖管理工具，类似于Centos中的yum。 1npm install -g hexo-cli 强烈建议浏览 Hexo官方文档，写的非常详细。 初始化博客123hexo init 自定义文件夹cd 自定义文件夹npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml #博客的全局配置文件├── package.json #包含了应用程序的信息├── scaffolds #模板文件夹├── source #用户资源文件夹| ├── _drafts #草稿箱| └── _posts #写的文章放到这里└── themes #主题文件夹 _config.yml文件详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo #网站标题subtitle: #网站副标题description: #网站描述keywords: #关键字author: John Doe #网站作者language: #网站所使用的语言 中文使用 zh-Hans 防止乱码timezone: #网站时区 Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com #网址root: / #网站根目录permalink: :year/:month/:day/:title/ #文章的 永久链接 格式permalink_defaults: #永久链接中各部分的默认值# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 # http://yoursite.com/blog 并把 root 设为 /blog/。# Directorysource_dir: source #资源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 # Writingnew_post_name: :title.md #新文章的文件名称default_layout: post #预设布局titlecase: false #把标题转换为 title caseexternal_link: true #在新标签中打开链接filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址future: true #显示未来的文章highlight: #代码块的设置 enable: true #是否开启代码块支持 line_number: true #显示行号 auto_detect: false tab_replace: #设置用什么字符替代Tab，如tab_replace: aaa，在代码中将输入tab的地方替换为aaa # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式# Pagination## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章条数pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape #当前所使用的主题名# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #部署部分设置 type: #部署类型 根据需要更改配置文件，进行个性化配置 启动Hexo服务初始化完成后，就可以启动Hexo服务了，进入博客目录，执行以下命令，即可启动服务 12hexo g #生成静态文件hexo s #启动hexo服务 打开浏览器，输入http://localhost:4000/ 配置了这么长时间，终于看到点效果了，有没有很激动O(∩_∩)O Hexo基本命令1234567hexo generate #生成静态文件，可以简写为 hexo ghexo clean #清除生成的静态文件hexo server #启动hexo服务进行预览，可以简写为 hexo shexo deploy #部署到服务器，可以简写为hexo dhexo new "文件名" #创建新文章hexo new draft "文件名" #创建草稿箱文章hexo new page "页面名" #创建新页面 配置部署到GitHub更改_config.yml配置文件的deploy部分。 1234deploy: type: git repo: https://github.com/xxx/xxx.github.io.git branch: master #部署的分支 或者 1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master #部署的分支 部署到GitHub1hexo d 自定义域名首先要有注册好的域名，没有的话，可以先去注册。域名的注册这里不多介绍了，资料很多，大家可以自己选择域名注册商进行注册。 CNAME类型解析注册好域名后，在博客的资源文件夹source下创建一个文件，CNAME，注意，这个文件没有后缀。使用文本编辑器打开，填入自己的域名，并保存。 登录自己的域名解析后台，添加一条解析记录。记录类型选择CNAME，记录值填入之前GItHub分配的访问路径xxx.github.io，保存后就可以用自己的域名访问博客了。 注意：CNAME文件一定要放在source路径下，否则下次部署的时候，CNAME就被删除了。 A类型解析在自己的域名解析后台添加一条解析记录，记录类型选择A，记录值填写自己项目访问路径的IP地址。如果不清楚IP地址，可以通过ping 项目访问路径的方式获得，然后填入记录值中即可。 Hexo更换next主题安装next主题建议根据官方文档安装，遇到不明白的地方再找别的资料参考 next官方文档 Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。 cd 到你的博客路径下，使用git下载主题文件 1git clone https://github.com/iissnan/hexo-theme-next themes/next 修改博客配置文件_config.yml，将theme: landscape修改为theme: next 启动服务即可。 上面的界面是我美化后的效果，图片仅供参考。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>自建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要写博客]]></title>
    <url>%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[关于写博客，自建博客的一些个人看法 写博客的原因记录解决问题的步骤，方便查阅&emsp;&emsp;首先作为程序员来讲，工作中都会遇到很多自己解决不了的问题。很多时候自己都是习惯去Google，或者各个博客看别人的解决办法，然后尝试解决问题。在这个过程中，发现很多人写的都是错误的，经常是按照A写的做，做完发现不对，又按照B写的做，发现又不对…… 最后终于将问题解决了，过一段时间遇到相同的问题，却又想不起来当初是怎么解决的。有了博客，就可以记录查阅了。 知识，只有自己总结后，才是自己的&emsp;&emsp;俗话说眼过千遍，不如手过一遍。这句话在编程界尤为适用。某个知识点，看着别人写的，感觉自己都会了，等到自己动手写的时候，脑子里空空如也，半棍子打不出一个屁来。有了博客，在写博客的时候，就会强迫自己将知识点深入理解，也算是知识梳理的过程吧。 提高写作水平&emsp;&emsp;其实自己一直有一个写作的梦想，当年读高中时，还曾经写过一本侦探小说🤣。写博客，可以练习练习语言组织能力，天天写代码，有时候连话都说不太清了。 自建博客的原因不信任第三方博客&emsp;&emsp;网络世界错综复杂，各个博客平台此消彼长。说不定到那一天，自己所在的平台就消失了，到时候当初自己辛辛苦苦写的东西也就随之消失。这是一件非常痛心的事情。 自己的地盘，可以尽情折腾&emsp;&emsp;大概程序员都喜欢自己折腾吧。自建博客，所有的东西都是自己说了算，感觉非常自由。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
