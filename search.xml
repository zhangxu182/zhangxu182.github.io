<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux配置springboot开机自启]]></title>
    <url>%2FLinux%E9%85%8D%E7%BD%AEspringboot%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%2F</url>
    <content type="text"><![CDATA[本文介绍了Linux环境下，自定义服务的开机自启 背景&emsp;&emsp;对于不使用云服务器的公司而言，服务器断电是一件很头痛的事。最近公司的一个外包项目上线了，但甲方三天两头打电话，说服务没办法访问。最后才找出原因，他们的服务器断过电。一开始，我以为是偶发事件，结果是他们的服务器经常性的断电。每次断电重启后，都要打电话给我，重新启动项目，非常麻烦。能不能配置一下服务器，在开机的时候就启动指定的服务呢？ 配置关于Linux服务开机自启，有三种方式。 &emsp;&emsp;关于Linux服务开机自启，有三种方式。 编辑/etc/rc.local使用vi编辑此文件，直接添加要执行的命令就行 12345678910111213141516#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.touch /var/lock/subsys/local# 这里是自定义的执行命令nohup /usr/java/jdk1.8.0_162/bin/java -jar /data/wwwroot/api/speed-api-0.0.1-SNAPSHOT.jar &amp;&gt;/dev/null 这里有一点需要注意，即使配置过环境变量，在这里也要指定java命令的路径，否则会有如下错误。 12nohup: ignoring inputnohup: failed to run command `java': No such file or directory 因为在加载执行此文件的时候，环境变量还未生效。 写脚本，放入/etc/profile.d自己写一个shell脚本，放在此路径下，系统启动时会自动执行。 123456[root@localhost ~]# cd /etc/profile.d/[root@localhost profile.d]# vi mystart.sh#!/bin/bashnohup /usr/local/java/jdk1.8.0_162/bin/java -jar /data/wwwroot/api/speed-api-0.0.1 -SNAPSHOT.jar &amp;&gt;/dev/null 此处同上，依然使用完全限定的java命令来执行。编写完脚本后，要为脚本分配可执行权限。 1[root@localhost profile.d]# chmod a+x mystart.sh 使用chkconfig命令执行自己写脚本，放入/etc/init.d下 12345678[root@localhost ~]# cd /etc/init.d[root@localhost init.d]# vi speed-start#!/bin/bash# chkconfig: - 95 15# description: speed-api start scriptnohup /usr/local/java/jdk1.8.0_162/bin/java -jar /data/wwwroot/api/speed-api-0.0.1-SNAPSHOT.jar &amp;&gt;/data/wwwroot/api/mylog.log 保存脚本，并赋予执行权限 1[root@localhost init.d]# chmod a+x speed-start 添加到chkconfig中，并设置开机启动 12[root@localhost init.d]# chkconfig --add speed-start[root@localhost init.d]# chkconfig speed-start on 这样，当下次服务器重启时，项目就可以自己启动了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程的中断机制]]></title>
    <url>%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[调用Thread.stop()该方法强迫停止一个线程，并抛出一个新创建的ThreadDeath对象作为异常。然而，Thread.stop()不安全，已不建议使用。 使用Thread.interrupt()&emsp;&emsp;Java中断机制是一种协作机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。 &emsp;&emsp;Java中断模型也可以简单做如下理解，每个线程对象里都有一个boolean类型的标识，代表着是否有中断请求(该请求可以来自所有线程，包括被中断的线程本身)。例如：当线程t1想中断线程t2，只需要在线程t1中将线程t2对象的中断标识置为true，然后线程t2可以选择在合适的时候处理该中断请求，甚至可以不理会该请求，就像没有被中断一样。 Thread类中关于中断的方法： public boolean isInterrupted()：测试线程是否已经中断。 public void interrupt()：中断线程。 1234567891011121314151617181920212223public class ThreadTest2 &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; boolean stop = true; while (stop) &#123; System.out.println("thread is running..."); long time = System.currentTimeMillis(); // 延时1s while (System.currentTimeMillis() - time &lt; 1000) &#123; &#125; &#125; &#125;; Thread thread = new Thread(runnable, "test Thread"); System.out.println("启动线程"); thread.start(); Thread.sleep(3000); thread.interrupt(); // 中断线程 System.out.println("线程是否中断：" + thread.isInterrupted()); &#125;&#125; 输出结果如下： 12345678910启动线程thread is running...thread is running...thread is running...thread is running...线程是否中断：truethread is running...thread is running...thread is running......... 从运行结果上看，线程并没有结束，因为线程2并没有处理该中断请求。接下来，我们对例子稍加改进： 1234567891011121314151617181920212223242526272829public class ThreadTest2 &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; boolean stop = true; while (stop) &#123; System.out.println("thread is running..."); long time = System.currentTimeMillis(); // 延时1s while (System.currentTimeMillis() - time &lt; 1000) &#123; &#125; // 注意这里 ==================== if (Thread.currentThread().isInterrupted()) &#123; System.out.println("线程中断后退出"); break; &#125; // 注意这里 ==================== &#125; &#125;; Thread thread = new Thread(runnable, "test Thread"); System.out.println("启动线程"); thread.start(); Thread.sleep(3000); thread.interrupt(); // 中断线程 System.out.println("线程是否中断：" + thread.isInterrupted()); &#125;&#125; 输出结果如下： 1234567启动线程thread is running...thread is running...thread is running...thread is running...线程是否中断：true线程中断后退出 此时线程2才真正终止结束了。 注意&emsp;&emsp;如果线程处在可中断状态下（调用了Thread.wait()或者Thread.sleep()等特定会发生阻塞的api），那么该线程会被立即唤醒，同时抛出一个InterruptedException。简单的异常处理如下： 1234567891011Runnable runnable = () -&gt; &#123; boolean stop = true; while (stop) &#123; System.out.println("thread is running..."); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; break; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程中断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建线程的三种方法]]></title>
    <url>%2F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java中创建线程的三种写法 继承Thread类，重写run()方法1234567891011public class ThreadTest1 extends Thread &#123; @Override public void run() &#123; System.out.println("线程启动了"); &#125; public static void main(String[] args) &#123; ThreadTest1 threadTest1 = new ThreadTest1(); threadTest1.start(); // 启动线程 &#125;&#125; 这种实现方式的缺点是一个类只能继承一个父类，类的可扩展性差。 实现Runnable接口，重写run()方法123456789101112public class ThreadTest2 implements Runnable &#123; @Override public void run() &#123; System.out.println("线程启动了"); &#125; public static void main(String[] args) &#123; Thread thread = new Thread(new ThreadTest2()); thread.start(); // 启动线程 &#125;&#125; 这种写法就比第一种的扩展性要好。毕竟Java是可以多实现的。 当然，也可以使用匿名内部类的方式进行简写，写法如下： 123456789101112public class ThreadTest3 &#123; public static void main(String[] args) &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; System.out.println("线程启动了"); &#125; &#125;; thread.start(); &#125;&#125; 如果你用的JDK的版本是8以上的，还可以使用lambda表达式再次进行简写： 1234567public class ThreadTest4 &#123; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; System.out.println("线程启动了"); &#125;).start(); &#125;&#125; 实现Callable接口，重写call()方法1234567891011121314public class ThreadTest5 implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println("启动线程"); return "thread"; &#125; public static void main(String[] args) &#123; FutureTask&lt;String&gt; task = new FutureTask&lt;&gt;(new ThreadTest5()); Thread thread = new Thread(task); thread.start(); &#125;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下MySQL5.7的安装配置]]></title>
    <url>%2Fwindows%E4%B8%8BMySQL5-7%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文介绍了在windows环境下的MySQL5.7的安装配置 下载点击这里进入官网下载。 根据自己的需求，选择对应的版本下载即可。 解压配置基本配置下载好的包，解压后是没有exe执行文件的，需要我们使用命令行进行配置安装。 将解压后的文件放入到自己习惯的软件安装路径，我放到了D:\soft下，并将文件夹重命名为mysql。 进入D:\soft\mysql下，新建一个空的文件，并重命名为my.ini。 使用文本编辑器打开my.ini文件，将以下内容复制进去，并保存。 12345678910111213141516[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]#设置3306端口port = 3306 # 设置mysql的安装目录basedir=D:/soft/mysql# 设置mysql数据库的数据的存放目录datadir=D:/soft/mysql/data# 允许最大连接数max_connections=500# 服务端字符编码character-set-server=utf8# 默认存储引擎default-storage-engine=INNODB 环境变量桌面我的电脑 右键–&gt;属性–&gt;高级系统设置–&gt;环境变量，打开环境变量编辑界面。 在系统变量里，找到Path变量，双击进入编辑界面。 点击确定即可。 安装MySQL安装服务以管理员身份，运行cmd，进入MySQL文件夹路径。 12345C:\WINDOWS\system32&gt;cd D:soft\mysqlC:\WINDOWS\system32&gt;D:D:\soft\mysql&gt; 执行安装命令，安装MySQL服务。 1234D:\soft\mysql&gt;mysqld installService successfully installed.D:\soft\mysql&gt; 如果输出Service successfully installed.，表示MySQL服务安装成功。 初始化数据库123D:\soft\mysql&gt;mysqld initializeD:\soft\mysql&gt; 初始化完毕后，会自动生成一个文件夹，这个文件夹位于 my.ini配置项中datadir=指定的位置。 配置root账户数据库初始化后，root账户的密码是随机的，无法登录。我们需要重新设置root账户密码。 1D:\soft\mysql&gt;mysqld --skip-grant-tables 输入以上命令，会开启免密登录的MySQL服务，此时命令行处于暂停状态无法使用。 新打开一个命令行，执行mysql -u root，就可以连接上MySQL了。 1234567891011121314C:\WINDOWS\system32&gt;mysql -u rootWelcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; 执行flush privileges;刷新权限。 执行grant all privileges on *.* to &#39;root&#39;@&#39;localhost&#39; identified by &#39;自定义密码&#39; with grant option;修改密码 再次执行flush privileges;生效修改。 输入exit退出MySQL。 1234567891011121314151617181920212223C:\WINDOWS\system32&gt;mysql -u rootWelcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; flush privileges;Query OK, 0 rows affected (0.01 sec)mysql&gt; grant all privileges on *.* to 'root'@'localhost' identified by 'xxx' with grant option;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; exit 打开任务管理器，找到MySQL的进程，结束掉。 再次打开cmd，输入命令启动MySQL，就可以正常使用了。 1234567891011121314151617181920C:\WINDOWS\system32&gt;net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。C:\WINDOWS\system32&gt;mysql -u root -pEnter password: *******Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.22 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nginx和tomcat配置负载均衡]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8nginx%E5%92%8Ctomcat%E9%85%8D%E7%BD%AE%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[本文介绍了使用nginx和tomcat配置简单的负载均衡 背景做开发的常常会遇到这样一个问题：项目上线了，而后续又需要添加新功能，常常是把服务停掉，将新功能部署到服务器上，再重启服务器。这样会导致服务一段时间不可用，能不能不停服务器把新功能更新呢？ 说明我们可以使用nginx和多个tomcat实现这样的效果，当需要部署新功能时，可以先停掉一个tomcat进行部署，此时如果有客户端进行请求，nginx会自动将请求转发到运行的tomcat中。等部署完成后再启动，nginx检测到服务可用时，就会自动将请求转发到正常运行的tomcat中。这样就完成了不停机更新。 准备安装Nginxnginx安装方式有好多种，我这里偷个懒，使用oneinstack一键安装脚本进行安装。如果你对这个感兴趣，可以到这里去看看。安装过程很简单，执行脚本后，就可以自动安装上。 安装tomcattomcat是不用进行安装的，直接解压就可以使用，可以从tomcat官网获取需要的版本。在Linux下使用wget下载。 123wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz# 解压tar -zxvf apache-tomcat-8.5.32.tar.gz 将tomcat复制两份，我放到/usr/local下，这个位置大家可以随意放置 12cp -r apache-tomcat-8.5.32 /usr/local/tomcat1cp -r apache-tomcat-8.5.32 /usr/local/tomcat2 修改tomcat2的端口号，否则无法启动两个tomcat。将conf/service.xml中的 8005 8080 8009 分别修改成其他的端口号，比如 8006 8081 8010。 为了方便看效果，修改tomcat中的webapps/ROOT/index.jsp，在其中加入如下代码 1&lt;h1&gt;tomcat1&lt;/h1&gt; tomcat2类似。这样tomcat就配置好了。分别启动两个tomcat进行访问测试。 如果浏览器无法访问，请检查防火墙是否阻止了端口。 Nginx配置编辑nginx的配置文件nginx.conf，在http{}中加入如下配置： 1234upstream test &#123; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; 在server{}中加入如下配置： 12345location / &#123; root html; index index.html index.htm index.jsp; proxy_pass http://test;&#125; 然后重启nginx 1/usr/local/nginx/sbin/nginx -s reload 此时再次访问的时候，就可以看到效果了。多次刷新页面，可以看到tomcat1和tomcat2互相切换，这样简单的负载均衡就配置好了。 负载均衡策略轮询默认的配置，请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器宕掉，能自动剔除。 1234upstream test &#123; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; 最少连接请求会转发到连接最少的服务器上处理 12345upstream test &#123; least_conn; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; weight 权重指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况，weight默认是1。 12345upstream test &#123; # 服务器A和服务器B的访问比例为：2-1;比如有3个请求，前两个会访问A，三个访问B，其它规则和轮询一样 server 127.0.0.1:8080 weight=2; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; ip_hash每个请求按访问ip的hash值分配，这样同一客户端连续的Web请求都会被分发到同一服务器进行处理，可以解决session的问题。当后台服务器宕机时，会自动跳转到其它服务器。 12345upstream test &#123; ip_hash; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; url_hash（第三方）url_hash是nginx的第三方模块，nginx本身不支持，需要打补丁。 nginx按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器、文件服务器、静态服务器时比较有效。缺点是当后端服务器宕机的时候，url_hash不会自动跳转的其他缓存服务器，而是返回给用户一个503错误。 12345upstream nginxDemo &#123; hash $request_url; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; fair按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream nginxDemo &#123; fair; server 127.0.0.1:8080; #tomcat1访问地址 server 127.0.0.1:8081; #tomcat2访问地址&#125; 参考链接：https://my.oschina.net/bgq365/blog/870569]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>tomcat</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己搭建Shadowsocks服务器]]></title>
    <url>%2F%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BAShadowsocks%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本文介绍了在Linux环境下搭建Shadowsocks服务器的方法 前言首先必须要有一个国外的服务器(废话)，我这里使用亚马逊的服务器为例，系统版本是redhat7.5。 安装过程使用Shadowsocks 一键安装脚本（四合一）脚本工具进行安装。 使用root账户，执行如下命令： 123[root@tom ~]# wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh[root@tom ~]# chmod +x shadowsocks-all.sh[root@tom ~]# ./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 注意：如果没有wget 工具，需要安装一下： 1yum install -y wget 如果不出意外的话，会自动执行交互式安装程序。最终安装成功后会输出如下信息： 12345678910111213Congratulations, your_shadowsocks_version install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_methodYour QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients) ss://your_encryption_method:your_password@your_server_ip:your_server_portYour QR Code has been saved as a PNG file path: your_path.pngWelcome to visit:https://teddysun.com/486.htmlEnjoy it! 服务器安装好后，就可以在客户端配置使用了，这里放上客户端的下载链接。 常规版 Windows 客户端https://github.com/shadowsocks/shadowsocks-windows/releases ShadowsocksR 版 Windows 客户端https://github.com/shadowsocksrr/shadowsocksr-csharp/releases 遇到的问题我在安装过程中，遇到了两个包依赖问题导致安装失败，这两个包分别是epel和qrencode，最后通过手动安装解决了依赖问题。具体的命令如下： 1234# 下载epel依赖包wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# 安装依赖yum install epel-release-latest-7.noarch.rpm qrencode包的下载地址：下载地址 我这里选择Centos 7 的包进行下载，大家可以根据自己的系统选择对应的包进行下载。 1234# 下载依赖wget http://mirror.centos.org/centos/7/os/x86_64/Packages/qrencode-3.4.1-3.el7.x86_64.rpm# 安装yum install qrencode-3.4.1-3.el7.x86_64.rpm 依赖安装好以后，再次执行Shadowsocks的安装脚本，就可以完成安装了。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用xx-net实现科学上网]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8xx-net%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[本文介绍了使用xx-net科学上网的详细流程 下载点击xx-net进入下载页面 下载完成后，本地解压，根据官网的教程操作即可。 文档地址 遇到的问题无法开启IPv6。其实这个不用根据官网的开启方法开启，下载好的包里就有开启脚本。具体的路径如下： XX-Net-3.12.2\code\default\gae_proxy\local\ipv6_tunnel\disable_ipv6.bat XX-Net-3.12.2\code\default\gae_proxy\local\ipv6_tunnel\enable_ipv6.bat 直接双击执行这两个脚本就可以了。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot自定义json格式转换]]></title>
    <url>%2Fspringboot%E8%87%AA%E5%AE%9A%E4%B9%89json%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[最近在看JDK8的新功能，在项目中使用了新的时间API，结果却引发了一个问题，本篇文章详细介绍了问题的出现以及解决方法。 错误的出现web项目中，我们常常会定义实体类，来对应数据库的表。 12345678910public class User implements Serializable &#123; private Integer id; private String name; private String password; private Instant created;&#125; 在上面的实体类中，我使用了JDK8中新的API java.time.Instant来替代java.util.Date类。经过测试后，可以使用mybatis正常操作数据库。但当写接口返回json时，created字段原本应该返回时间戳，但却返回成了浮点数。 1"created":1522234791.000000000 解决办法Instant中是由toEpochMilli()方法转为时间戳的，我们可以自定义一个JsonSerializer来进行转换。 1234567public class InstantConverter extends JsonSerializer&lt;Instant&gt; &#123; @Override public void serialize(Instant value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123; gen.writeNumber(value.toEpochMilli()); &#125;&#125; 定义完成后，需要在指定的属性上加@JsonSerialize(using = 自定义转换方法.class)，来标注。这样当返回json数据时，会自动调用我们的方法进行格式转换。 修改后的实体类 1234567891011public class User implements Serializable &#123; private Integer id; private String name; private String password; @JsonSerialize(using = InstantConverter.class) private Instant created;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot将项目与依赖分开打包]]></title>
    <url>%2Fspringboot%E5%B0%86%E9%A1%B9%E7%9B%AE%E4%B8%8E%E4%BE%9D%E8%B5%96%E5%88%86%E5%BC%80%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文介绍了在spring boot项目中，配置项目与依赖分开打包的方法 写在前面的&emsp;&emsp;当我们使用spring boot写项目时，一般都会遇到一个问题，那就是spring boot打包时，会将自己写的代码和项目的所有依赖文件打成一个可执行的jar包。通常我们的项目都是运行在服务器上的，当项目更新时，每次都要向服务器上传这个包。如果项目的依赖包很多，那么这个文件就会非常大。大文件上传不仅浪费带宽，有时候网络不稳定，传输一半断网，又要重新上传，非常麻烦。 默认的maven配置 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; &emsp;&emsp;如果能将项目外部依赖和自己的代码包分开打包，当修改项目后，只需要再次覆盖修改后的包，那岂不是美滋滋？ 解决方案使用maven的assembly打包插件 assembly配置&emsp;&emsp;在项目中创建一个文件，我放在src/main/assembly/assembly.xml中，大家可以根据喜好自己创建。 assembly中的具体配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd"&gt; &lt;!-- 必须写，否则打包时会有 assembly ID must be present and non-empty 错误 这个名字最终会追加到打包的名字的末尾，如项目的名字为 speed-api-0.0.1-SNAPSHOT, 则最终生成的包名为 speed-api-0.0.1-SNAPSHOT-bin.zip --&gt; &lt;id&gt;bin&lt;/id&gt; &lt;!-- 打包后的文件格式,可以是zip,tar,tar.gz,tar.bz2,jar,war,dir --&gt; &lt;formats&gt; &lt;format&gt;zip&lt;/format&gt; &lt;/formats&gt; &lt;!-- 压缩包下是否生成和项目名相同的根目录 --&gt; &lt;includeBaseDirectory&gt;false&lt;/includeBaseDirectory&gt; &lt;dependencySets&gt; &lt;dependencySet&gt; &lt;!-- 不使用项目的artifact，第三方jar不要解压，打包进zip文件的lib目录 --&gt; &lt;useProjectArtifact&gt;false&lt;/useProjectArtifact&gt; &lt;outputDirectory&gt;lib&lt;/outputDirectory&gt; &lt;unpack&gt;false&lt;/unpack&gt; &lt;/dependencySet&gt; &lt;/dependencySets&gt; &lt;fileSets&gt; &lt;!-- 把项目相关的说明文件，打包进zip文件的根目录 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;project.basedir&#125;&lt;/directory&gt; &lt;outputDirectory&gt;&lt;/outputDirectory&gt; &lt;includes&gt; &lt;include&gt;README*&lt;/include&gt; &lt;include&gt;LICENSE*&lt;/include&gt; &lt;include&gt;NOTICE*&lt;/include&gt; &lt;/includes&gt; &lt;/fileSet&gt; &lt;!-- 把项目的配置文件，打包进zip文件的config目录 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;outputDirectory&gt;config&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;!-- 把项目的脚本文件，打包进zip文件的bin目录 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/bin&lt;/directory&gt; &lt;outputDirectory&gt;bin&lt;/outputDirectory&gt; &lt;/fileSet&gt; &lt;!-- 把项目自己编译出来的jar文件，打包进zip文件的根目录 --&gt; &lt;fileSet&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;outputDirectory&gt;&lt;/outputDirectory&gt; &lt;includes&gt; &lt;include&gt;*.jar&lt;/include&gt; &lt;/includes&gt; &lt;/fileSet&gt; &lt;/fileSets&gt;&lt;/assembly&gt; maven中的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;build&gt; &lt;plugins&gt; &lt;!-- 指定启动类，将依赖打成外部jar包 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;!-- 生成的jar中，不要包含pom.xml和pom.properties这两个文件 --&gt; &lt;addMavenDescriptor&gt;false&lt;/addMavenDescriptor&gt; &lt;manifest&gt; &lt;!-- 是否要把第三方jar放到manifest的classpath中 --&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;!-- 外部依赖jar包的最终位置 --&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;!-- 项目启动类 --&gt; &lt;mainClass&gt;com.zbrx.speed.App&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 使用assembly打包 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;descriptors&gt; &lt;!-- assembly配置文件位置 --&gt; &lt;descriptor&gt;src/main/assembly/assembly.xml&lt;/descriptor&gt; &lt;/descriptors&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assembly&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- 打包发布时，跳过单元测试 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 最终打包后的效果 压缩包里的文件内容 lib中的文件 config配置文件 因为我没有写启动脚本，所以没有bin文件夹。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新功能-接口可以实现方法]]></title>
    <url>%2FJava8%E6%96%B0%E5%8A%9F%E8%83%BD-%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java8中，接口不仅仅可以定义方法，还可以实现方法 接口定义123456789101112public interface InterfaceTest &#123; default void test1() &#123; System.out.println("test1"); &#125; static int test2() &#123; System.out.println("test2"); return 0; &#125; String getName();&#125; 接口可以使用default和static两个修饰符定义方法，同一个方法不能同时使用这两个修饰符。 使用static修饰的方法，可以直接使用接口.方法名的方式进行调用。 使用default修饰的方法，在子类中无需重写，也可调用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新功能-lambda表达式]]></title>
    <url>%2FJava8%E6%96%B0%E5%8A%9F%E8%83%BD-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java8中新增的lambda表达式的介绍和用法 为什么需要lambda表达式场景在JDK8以前，如果我们需要临时创建一个线程，通常使用匿名内部类的方式实现。 123456789public void test1() &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread()); &#125; &#125;); thread.start();&#125; 当我们需要对集合进行自定义排序时，通常这么写 12345678910111213public void test2() &#123; List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add("tom"); names.add("jerry"); names.sort(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o1.length() - o2.length(); &#125; &#125;); System.out.println(names);&#125; 上面两个例子中，我们都是将一段代码当作参数，传入方法中。 使用lambda在JDK8中，我们可以使用lambda表达式简化代码。 创建线程 123456public void test3() &#123; Thread thread = new Thread(() -&gt; &#123; System.out.println(Thread.currentThread()); &#125;); thread.start();&#125; 自定义比较器 123456789public void test4() &#123; List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.add("tom"); names.add("jerry"); names.sort((o1, o2) -&gt; &#123; return Integer.compare(o1.length(), o2.length()); &#125;); System.out.println(names);&#125; ()里写参数名，如果没有参数，可以不写。{}里写表达式，如果无法用一个表达式表示，也可以写多条语句。 12345names.sort((o1, o2) -&gt; &#123; System.out.println("123"); ... return Integer.compare(o1.length(), o2.length());&#125;); 参数的类型如果可以被推导，也可以省略。 如果需要赋值，也可以这样： 123Comparator&lt;String&gt; comparator = (o1, o2) -&gt; &#123; return Integer.compare(o1.length(), o2.length());&#125;;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring参数统一校验]]></title>
    <url>%2Fspring%E5%8F%82%E6%95%B0%E7%BB%9F%E4%B8%80%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[使用spring aop 实现特定接口参数统一校验 问题场景&emsp;&emsp;写过接口的人都会面临一个问题，那就是参数校验的问题。尽管客户端有参数校验，但经验告诉我们，仅仅依赖客户端是极大的错误。通常情况下，我们都应该认为，客户端传过来的参数都是不可信任的。每个参数都应该经过合理的校验才能使用，否则迟早会发生不可预料的问题。 &emsp;&emsp;基于上述的问题，最简单的解决办法就是在每个接口上，都加上参数校验。关键的地方来了，怎么加？接口少了还好说，修改代码就行，接口多了呢？几百个几千个，怎么办？ 使用AOP解决问题&emsp;&emsp;AOP(Aspect Oriented Programming )，中文叫面向切面编程。程序运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程 。其实本质上是一种动态代理技术。 &emsp;&emsp;有了AOP，我们就可以写一个通用的参数校验方法，对所有需要参数校验的接口进行统一处理了。而且对原来的代码没有侵入性，符合开闭原则。 下面是一个简单的例子： 1234567891011121314151617181920212223242526272829303132333435363738@Component@Aspectpublic class CheckParametersEmpty &#123; /** * 检查com.zbrx.speed.controller包下所有的返回值为ResultData的方法， * 如果参数有空，则阻止执行，并直接返回结果 * 否则继续执行 * @throws Throwable * */ @Around("execution(com.zbrx.speed.base.dto.ResultData com.zbrx.speed.controller..*.*(..))") public Object checkParam(ProceedingJoinPoint point) throws Throwable &#123; //获取方法的请求参数 Object[] params = point.getArgs(); //获取方法 Signature signature = point.getSignature(); MethodSignature methodSignature = (MethodSignature)signature; Method targetMethod = methodSignature.getMethod(); //检测方法上是否有 @IgnoreParams注解，如果有，则不检测参数，直接向下执行 IgnoreParams ignoreParams = targetMethod.getAnnotation(IgnoreParams.class); if (ignoreParams != null) &#123; //如果有注解 return point.proceed(params); //直接执行向下执行 &#125; //遍历参数，查看是否有空值 for (Object object : params) &#123; if (object == null) &#123; //如果参数有空值，直接返回 return ResultData.error(ResponseCode.PARAM_EMPTY); &#125; &#125; //否则继续往下执行 return point.proceed(params); &#125;&#125; @Around指定了切入点，也就是哪些方法需要进行参数校验。关于SpringAOP具体的介绍，我会在另一篇博客中说明。]]></content>
      <categories>
        <category>经验杂谈</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>aop</tag>
        <tag>经验杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理maven下载失败的jar包]]></title>
    <url>%2F%E6%B8%85%E7%90%86maven%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84jar%E5%8C%85%2F</url>
    <content type="text"><![CDATA[下载失败包的特征maven下载失败的包，会使用.lastUpdated作为文件的结尾。如果不清除这些包，maven不会自动再次下载。 清理方法明白了maven的处理方法，就比较好解决了，直接删除本地仓库里以.lastUpdated结尾的文件就可以了。这里介绍下两种方法。 手动删除打开本地仓库目录，使用windows文件搜索功能，搜索出文件，删除即可。 使用代码删除毕竟咱是程序员，有问题还是自己写代码解决比较好😆。代码思路非常简单，递归出符合命名的文件，然后删除就可以了。 12345678910111213141516171819202122232425262728293031323334public class MavenClear &#123; public static void main(String[] args) &#123; String filePath = "E:\\test"; delete(filePath); &#125; /** * 根据路径删除下载失败的jar包，下载失败的包以 .lastUpdated结尾 * * @param filePath */ public static void delete(String filePath) &#123; File file = new File(filePath); if (file.exists()) &#123; // 判断是文件还是目录 if (file.isFile()) &#123; if (file.getName().endsWith("lastUpdated")) &#123; file.delete(); System.out.println("删除：" + file.getAbsoluteFile()); &#125; &#125; // 如果是目录 if (file.isDirectory()) &#123; // 获取目录，并循环递归 File[] files = file.listFiles(); for (File f : files) &#123; delete(f.getAbsolutePath()); &#125; &#125; &#125; &#125;&#125; 代码其实也没几行，可以将其打包成可执行文件，直接点击运行就可以了。]]></content>
      <categories>
        <category>奇淫巧技</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty hello world]]></title>
    <url>%2Fnetty-hello-world%2F</url>
    <content type="text"><![CDATA[Java NIO 框架netty的简单介绍以及hello world程序示例 Netty简介&emsp;&emsp;Netty是一款NIO客户端服务器框架，可以快速轻松地开发协议服务器和客户端等网络应用程序。 它极大地简化并简化了TCP和UDP套接字服务器等网络编程。 &emsp;&emsp;’快速和简单’并不意味着由此产生的应用程序将受到可维护性或性能问题的困扰。 Netty的设计经验非常丰富，包括FTP，SMTP，HTTP以及各种基于二进制和基于文本的传统协议等。 因此，Netty成功地找到了一种方法来实现轻松的开发，性能，稳定性和灵活性，而无需妥协。 &emsp;&emsp;以上内容摘自Netty官网。 不建议使用Java原生NIO编程的原因 NIO的类库和API繁杂，使用麻烦，需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。 需要具备其他额外的技能做铺垫，例如熟悉Java的多线程编程。这是因为NIO涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的NIO程序。 可靠性能力补齐，工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等问题，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐的工作量和难度都非常大。 JDK NIO的bug，例如臭名昭著的epoll bug，他会导致Selector空轮询，最终导致CPU100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本改问题依旧存在，只不过是发生的概率低了一些，并没有得到根本性的解决。 为什么选择Netty&emsp;&emsp;Netty是业界最流行的NIO框架之一，它的健壮性、功能、性能、可定制性和可扩展性在同类框架中都是首屈一指的，他已经得到成百上千的商用项目验证，例如Haoop的RPC框架Avro就使用了Netty作为底层通信框架，其他还有业界主流的PRC框架，也使用Netty来构建高性能的异步通信能力。 Netty的优点如下： API使用简单，开发门槛低。 功能强大，预置了多种编解码功能，支持多种主流协议。 定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展。 性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优。 成熟、稳定，Netty修复了已经发现的所有JDK NIO bug，业务开发人员不需要在位NIO的bug烦恼。 社区活跃，版本迭代周期短，发现的bug可以被及时修复，同时，更多的新功能会加入。 经历了大规模的商业应用考验，质量得到验证。Netty在互联网、大数据、网络游戏、企业应用、电信软件等众多行业已经取得了成功商用，证明它已经完全能够满足不同行业的商业应用了。 Netty hello world Demo服务端自定义逻辑处理类 HelloServerHandler 123456789101112131415161718192021222324252627282930313233public class HelloServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; /** * 获取客户端发送的消息 * * @param channelHandlerContext * @param s * @throws Exception */ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123; // 收到消息直接打出 System.out.println(channelHandlerContext.channel().remoteAddress()+"说:" + s); // 向客户端发送消息 channelHandlerContext.writeAndFlush("服务器已收到消息，内容是：" + s + "\n"); &#125; /** * 建立连接后调用 * * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println(ctx.channel().remoteAddress()+"连接！"); // 向客户端发送消息 ctx.writeAndFlush("欢迎登录"+InetAddress.getLocalHost().getHostName()+"\n"); &#125;&#125; IO事件初始化类 HelloServerInitializer 12345678910111213141516171819public class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); // 以("\n")为结尾分割的 解码器 pipeline.addLast("framer", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter())); // 字符串解码 和 编码 pipeline.addLast("decoder", new StringDecoder()); pipeline.addLast("encoder", new StringEncoder()); // 自己的逻辑Handler pipeline.addLast("handler", new HelloServerHandler()); &#125;&#125; 服务端启动类 Server 123456789101112131415161718192021222324252627282930313233343536public class Server &#123; /** * 监听端口 */ private static final int PORT = 8888; public static void main(String[] args) &#123; // 用于接受客户端连接的线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(); // 用于进行SocketChannel读写的线程组 EventLoopGroup workerGroup = new NioEventLoopGroup(); // netty启动类 ServerBootstrap server = new ServerBootstrap(); // 将线程组配置到启动类中 server.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) // 创建ServerSocketChannel .childHandler(new HelloServerInitializer()); // 绑定IO事件处理类 try &#123; System.out.println("服务端已启动，等待客户端连接..."); // 服务器绑定端口 ChannelFuture future = server.bind(PORT).sync(); // 等待服务端监听端口关闭后，main函数才退出 future.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放线程组资源 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 客户端自定义业务逻辑处理类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class HelloClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; private Thread thread = null; /** * 获取服务器发送的消息 * * @param channelHandlerContext * @param s * @throws Exception */ @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123; System.out.println("服务器说："+s); &#125; /** * 建立连接后调用 * @param ctx * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; if (thread == null) &#123; thread = new Thread(() -&gt; &#123; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; String msg = scanner.next(); ctx.writeAndFlush(msg + "\n"); &#125; &#125;); thread.start(); &#125; &#125; /** * 与服务器断开连接后调用 * * @param ctx * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("客户端关闭"); super.channelInactive(ctx); &#125;&#125; IO事件初始化类 HelloClientInititlizer 123456789101112131415161718public class HelloClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); /* * 这个地方的 必须和服务端对应上。否则无法正常解码和编码 * */ pipeline.addLast("framer", new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter())); pipeline.addLast("decoder", new StringDecoder()); pipeline.addLast("encoder", new StringEncoder()); // 客户端的逻辑 pipeline.addLast("handler", new HelloClientHandler()); &#125;&#125; 客户端启动类Client 123456789101112131415161718192021222324252627282930public class Client &#123; /** 服务器IP */ private static final String HOST = "127.0.0.1"; /** 服务器端口号 */ private static final int PORT = 8888; public static void main(String[] args) &#123; // 创建NIO线程组 EventLoopGroup group = new NioEventLoopGroup(); // 创建NIO客户端 Bootstrap client = new Bootstrap(); // 将线程组配置到启动类中，并创建SocketChannel，设置处理类 client.group(group).channel(NioSocketChannel.class) .handler(new HelloClientInitializer()); try &#123; // 发起异步连接操作 ChannelFuture future = client.connect(HOST, PORT).sync(); // 关闭连接后，主函数退出。 future.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放线程组资源 group.shutdownGracefully(); &#125; &#125;&#125; 分别启动Server 和 Client 后，控制台输出 Server控制台输出1234服务端已启动，等待客户端连接.../127.0.0.1:53521连接！/127.0.0.1:53521说:hello/127.0.0.1:53521说:world Client控制台输出1234服务器说：欢迎登录zhangxuhello world 服务器说：服务器已收到消息，内容是：hello服务器说：服务器已收到消息，内容是：world]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pipe管道]]></title>
    <url>%2FPipe%E7%AE%A1%E9%81%93%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324public class PipeTest &#123; public static void main(String[] args) throws IOException &#123; Pipe pipe = Pipe.open(); // 通过管道发送数据 Pipe.SinkChannel sink = pipe.sink(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); byteBuffer.put("通过管道发送数据".getBytes()); byteBuffer.flip(); sink.write(byteBuffer); byteBuffer.clear(); // 接受数据 Pipe.SourceChannel source = pipe.source(); int len = source.read(byteBuffer); byteBuffer.flip(); System.out.println(new String(byteBuffer.array(), 0, len)); byteBuffer.clear(); sink.close(); source.close(); &#125;&#125;]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阻塞模型与非阻塞模型]]></title>
    <url>%2F%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java NIO 中的阻塞模型与非阻塞模型的实现 阻塞与非阻塞&emsp;&emsp;传统的IO都是阻塞式的。也就是说，当一个线程调用read()或write()方法时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在网络通信进行IO操作时，由于线程会阻塞，所以服务端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。 &emsp;&emsp;Java NIO 是非阻塞模型的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或者有限几个线程来同时处理连接到服务器端的所有客户端。 Selector&emsp;&emsp;选择器，用于监听客户端与服务端的连接。调用通道的register(Selector sel, int ops)方法，将通道注册到选择器上，参数ops是常量，用于设置选择器的监听事件。可以监听的事件类型列表： 事件名称 功能 SelectionKey.OP_READ 读 SelectionKey.OP_WRITE 写 SelectionKey.OP_CONNECT 连接 SelectionKey.OP_ACCEPT 接收 当监听多个事件时，可以使用|操作符连接 SelectionKey.OP_READ | SelectionKey.OP_WRITE 演示代码阻塞方式1234567891011121314151617@Testpublic void client() throws IOException &#123; try ( // 1.获取通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 10000)); FileChannel fileChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); ) &#123; // 2.分配缓存 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (fileChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); // 3.发送数据到服务端 socketChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125;&#125; 12345678910111213141516171819202122232425@Testpublic void server() &#123; try ( // 1.获取通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); FileChannel fileChannel = FileChannel.open(Paths.get("c.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; // 2.绑定端口 serverSocketChannel.bind(new InetSocketAddress(10000)); // 3.获取客户端连接 SocketChannel socketChannel = serverSocketChannel.accept(); // 4.获取客户端的数据，保存到本地 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (socketChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); fileChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 非阻塞模式12345678910111213141516171819202122232425public class Client &#123; public static void main(String[] args) &#123; try ( // 打开通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("localhost", 8888)); ) &#123; // 设置非阻塞模式 socketChannel.configureBlocking(false); // 创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 发送数据 Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; String msg = scanner.next(); byteBuffer.put(msg.getBytes()); byteBuffer.flip(); socketChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Server &#123; public static void main(String[] args) &#123; try ( // 打开通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); ) &#123; // 绑定端口 serverSocketChannel.bind(new InetSocketAddress(8888)); //设置非阻塞模式 serverSocketChannel.configureBlocking(false); // 获取选择器 Selector selector = Selector.open(); // 注册连接事件 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while (selector.select() &gt; 0) &#123; // 遍历注册事件，进行业务处理 Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while (it.hasNext()) &#123; SelectionKey key = it.next(); if (key.isAcceptable()) &#123; // 如果有客户端连接 SocketChannel socketChannel = serverSocketChannel.accept(); socketChannel.configureBlocking(false); // 注册读取事件，读取客户端发送的数据 socketChannel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; // 获取客户端的数据 SocketChannel socketChannel = (SocketChannel) key.channel(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int len = 0; while ((len = socketChannel.read(byteBuffer)) &gt; 0) &#123; byteBuffer.flip(); System.out.println("[客户端]："+new String(byteBuffer.array(), 0, len)); byteBuffer.clear(); &#125; &#125; // 清除已处理的事件 it.remove(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Channel通道]]></title>
    <url>%2FChannel%E9%80%9A%E9%81%93%2F</url>
    <content type="text"><![CDATA[Channel通道的获取与原理 简介表示io源与目标打开的连接。Channel类似于传统的流，只不过Channel本身不能直接访问数据，Channel只能与Buffer进行交互。 Channel的主要实现类：FileChannel，SocketChannel，ServerSocketChannel，DatagramChannel 获取通道使用getChannel()方法1234567891011121314151617181920212223public void test1() throws FileNotFoundException &#123; try( FileInputStream fileInputStream = new FileInputStream("a.txt"); FileOutputStream fileOutputStream = new FileOutputStream("b.txt"); // 1.获取通道 FileChannel inChannel = fileInputStream.getChannel(); FileChannel outChannel = fileOutputStream.getChannel(); ) &#123; // 2.创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); // 3.将通道中的数据存入缓冲区 while (inChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); //切换到读数据模式 outChannel.write(byteBuffer); byteBuffer.clear(); //清空缓冲区 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 使用静态open()方法1234567891011121314151617public void test2() &#123; try( FileChannel inChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; // 内存映射文件 MappedByteBuffer inMappedByteBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMappedByteBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size()); byte[] dst = new byte[inMappedByteBuffer.limit()]; inMappedByteBuffer.get(dst); outMappedByteBuffer.put(dst); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 使用Files工具类中的静态方法 newByteChannel()1234567891011121314151617181920public void test3() &#123; try ( // 获取Channel，Files只能获取ByteChannel ByteChannel inChannel = Files.newByteChannel(Paths.get("a.txt"), StandardOpenOption.READ); ByteChannel outChannel = Files.newByteChannel(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; // 创建缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (inChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); outChannel.write(byteBuffer); byteBuffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 通道之间的互相传输12345678910111213public void test4() &#123; try ( FileChannel inChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; //inChannel.transferTo(0, inChannel.size(), outChannel); // 或者 outChannel.transferFrom(inChannel, 0, inChannel.size()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 分散读取与聚集写入 12345678910111213141516171819public void test5() &#123; try ( FileChannel fileChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); ) &#123; // 分配缓冲区 ByteBuffer buffer1 = ByteBuffer.allocate(9); ByteBuffer buffer2 = ByteBuffer.allocate(6); ByteBuffer[] byteBuffers = &#123;buffer1, buffer2&#125;; // 分散读取 fileChannel.read(byteBuffers); for (ByteBuffer byteBuffer : byteBuffers) &#123; byteBuffer.flip(); System.out.println(byteBuffer + new String(byteBuffer.array())); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 123456789101112131415161718192021public void test6() &#123; try ( FileChannel inChannel = FileChannel.open(Paths.get("a.txt"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get("b.txt"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE); ) &#123; ByteBuffer buffer1 = ByteBuffer.allocate(72); ByteBuffer buffer2 = ByteBuffer.allocate(72); ByteBuffer[] buffers = &#123;buffer1, buffer2&#125;; inChannel.read(buffers); for (ByteBuffer buffer : buffers) &#123; buffer.flip(); &#125; // 聚集写入 outChannel.write(buffers); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Java</tag>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Buffer缓冲区]]></title>
    <url>%2FBuffer%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[NIO 中Buffer缓冲区介绍及基本操作 简介Buffer(缓冲区)，在Java NIO中负责数据的存取。缓冲区本质上就是数组，用于存储不同数据类型的数据。 根据数据类型不同(boolean除外)，提供了相应类型的缓冲区 ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 缓冲区可以通过allocate()获取缓冲区 12// 创建一个指定大小的缓冲区ByteBuffer byteBuffer = ByteBuffer.allocate(1024); 直接缓冲区与非直接缓冲区通过allocate()方式创建的缓冲区，称为非直接缓冲区，这种缓冲区是在jvm中创建的。 通过allocateDirect()创建的缓冲区，称为直接缓冲区，这种缓冲区是在物理内存中直接创建的。 使用allocateDirect()所需要的成本比allocate()要高，而且无法使用垃圾自动回收。 四个核心属性 capacity：容量，表示缓冲区中最大存储数据的容量，一旦声明不能改变 limit：界限，表示缓冲区中可以操作数据的大小。(limit后数据不能进行读写)。 position：位置，表示缓冲区中正在操作数据的位置。 mark：标记，表示当前position的位置，可以通过reset()恢复到mark的位置 四个属性的关系：0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity 常用操作allocate()：创建缓冲区 1234ByteBuffer byteBuffer = ByteBuffer.allocate(1024);System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //1024System.out.println("capacity: "+byteBuffer.capacity()); //1024 put()：向缓冲区中写数据 12345String name = "tom";byteBuffer.put(name.getBytes());System.out.println("position: "+byteBuffer.position()); //3System.out.println("limit: "+byteBuffer.limit()); //1024System.out.println("capacity: "+byteBuffer.capacity()); //1024 flip()：切换到读数据模式 1234byteBuffer.flip();System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //3System.out.println("capacity: "+byteBuffer.capacity()); //1024 get()：读取缓冲区中的数据 123456byte[] dst = new byte[byteBuffer.limit()];byteBuffer.get(dst);System.out.println("buffer中的数据："+new String(dst, 0, dst.length));System.out.println("position: "+byteBuffer.position()); //3System.out.println("limit: "+byteBuffer.limit()); //3System.out.println("capacity: "+byteBuffer.capacity()); //1024 rewind()：重新从头读取数据 1234byteBuffer.rewind();System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //3System.out.println("capacity: "+byteBuffer.capacity()); //1024 clear()：清除缓冲区，数据依然存在。只是位置信息被初始化 1234byteBuffer.clear();System.out.println("position: "+byteBuffer.position()); //0System.out.println("limit: "+byteBuffer.limit()); //1024System.out.println("capacity: "+byteBuffer.capacity()); //1024 mark()：标记position的位置 1234byteBuffer.put("jerry".getBytes());byteBuffer.mark(); //当position为5时，进行标记byteBuffer.put("tom".getBytes());System.out.println("position: "+byteBuffer.position()); //8 reset()：恢复mark标记的position的位置 12byteBuffer.reset();System.out.println("position: "+byteBuffer.position()); //5]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Buffer</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO 概述]]></title>
    <url>%2FJava-NIO-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[Java NIO简介 Java NIO 简介Java NIO(New IO / Non Blocking IO)是从Java1.4 版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有相同的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO以更加高效的方式进行文件的读写操作。 NIO与IO的区别 IO NIO 面向流(Stream Oriented) 面向缓冲区(Buffer Oriented) 阻塞IO(Blocking IO) 非阻塞IO(Non Blocking IO) 选择器(Selectors) 通道和缓冲区Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到IO设备(如：文件、套接字)的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。 缓冲区是一个用于存放特定基本数据类型的容器。由java.nio包定义，所有的缓冲区都是Buffer抽象类的子类。缓冲区主要用来与通道进行交互，数据从通道读入缓冲区，从缓冲区写入通道。]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些感悟]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[最近的一些感悟 &emsp;&emsp;有十天没有写过东西了，今天刚好周末，说静下心来写写东西吧，结果坐下来想了想，似乎并没有什么要写的。感觉这一周仿佛什么都没有做一样。再往深处想一想，一年仅仅52周，如果每周都是这个样子，那么一年也就是这个样子了。一年是这个样子，十年呢，二十年呢？细思极恐，一辈子碌碌无为恐怕就是这样的吧。 &emsp;&emsp;似乎我们身边的人都感觉时间是最不值钱的东西，我们可以整天待在家里抱着手机看一天的视频或者小说，仗着自己年轻，尽情挥霍着大把大把的时间。然后感叹一下，哎，今天又虚度了一天。结果第二天依然如此，日复一日，年复一年。 &emsp;&emsp;世间虽有很多的不公，但在时间上，是绝对公平的。每个人所拥有的时间都是完全一样的。人与人的区别就在于时间利用上的不同而体现出来的。有的人是重复昨天，而有的人是活在今天。勤学似春起之苗,不见其增,日有所长;辍学如磨刀之石,不见其损,日有所亏。 &emsp;&emsp;与君共勉。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>瞎写</tag>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型模式之简单工厂]]></title>
    <url>%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[简单工厂模式的介绍及写法 简单工厂模式提供一个创建对象实例的功能，而无需关心其具体的实现。被创建的实例类可以是接口，抽象类，也可以是具体的类。简单工厂并不在23中设计模式中，更多的时候是一种编程习惯。它通过接受不同的参数来返回不同的对象。 示例代码想象一个场景，你需要用笔写 一封信，有三种笔：铅笔，圆珠笔，中性笔，每种笔都有write()方法。 先定义笔接口 123public interface Pen &#123; void write(String words);&#125; 铅笔类 123456public class Pencil implements Pen &#123; @Override public void write(String words) &#123; System.out.println("使用铅笔写："+words); &#125;&#125; 圆珠笔类 123456public class BallpointPen implements Pen &#123; @Override public void write(String words) &#123; System.out.println("使用圆珠笔写："+words); &#125;&#125; 中性笔类 123456public class GelPen implements Pen &#123; @Override public void write(String words) &#123; System.out.println("使用中性笔写："+words); &#125;&#125; 下面是工厂类的具体实现 12345678910111213public class PenFactory &#123; public static Pen getPen(String penType) &#123; if ("pencil".equalsIgnoreCase(penType)) &#123; return new Pencil(); &#125; else if ("gelpen".equalsIgnoreCase(penType)) &#123; return new GelPen(); &#125; else if ("ballpointpen".equalsIgnoreCase(penType)) &#123; return new BallpointPen(); &#125; else &#123; return null; &#125; &#125;&#125; 这个工厂类根据不同的penType，new 不同的Pen对象。 在客户端调用 铅笔写 12Pen pencil = PenFactory.getPen("pencil");pencil.write("Hi tom!"); 圆珠笔写 12Pen ballpointPen = PenFactory.getPen("ballpointpen");ballpointPen.write("Hi tom!"); 中性笔写 12Pen gelPen = PenFactory.getPen("gelpen");gelpen.write("Hi tom!"); 客户端只需要从工厂取自己需要的产品就可以，不需要自己new，降低了耦合度。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>简单工厂</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型模式之单例模式]]></title>
    <url>%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式介绍与写法 什么是单例模式单例模式，顾名思义，单个实例的模式。保证一个类只有一个实例，并提供一个访问该实例的全局访问点。 为什么要有单例模式在某些场景下，某个类只允许一个实例。如操作系统的资源管理器，任务管理器，读取配置文件的类等。如果一个操作系统有多个资源管理器，那系统就乱套了。项目中读取配置文件的类如果有多个，则会浪费不必要的内存空间。 常见的五种单例模式的实现懒汉单例懒汉单例模式，只有当使用到单例对象时，才会进行实例化操作。 1234567891011121314151617181920212223242526272829303132333435363738public class Singleton1 implements Serializable&#123; /** * 懒汉单例，具体使用时才会实例化(懒加载) */ private static Singleton1 instance; /** * 私有化构造器，防止通过new创建对象 */ private Singleton1() &#123; //防止通过反射创建对象 if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; /** * 获取单例对象 * 延时加载，当使用对象时才实例化 * * @return */ public synchronized static Singleton1 getInstance() &#123; if (instance == null) &#123; instance = new Singleton1(); &#125; return instance; &#125; /** * 防止反序列化时创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125;&#125; 饿汉单例饿汉单例模式，类初始化时立即实例化对象。 12345678910111213141516171819202122232425public class Singleton2 implements Serializable &#123; /** * 饿汉单例模式，类初始化时创建对象 */ private static Singleton2 instance = new Singleton2(); private Singleton2() &#123; //防止反射创建单例对象 if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; public static Singleton2 getInstance() &#123; return instance; &#125; /** * 防止反序列化创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125; 双重检查锁式单例在jdk1.5之前，使用这种方式偶尔会有问题，不建议使用。 123456789101112131415161718192021222324252627282930313233public class Singleton3 &#123; private static volatile Singleton3 instance; private Singleton3() &#123; if (instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; /** * 双重检查锁单例 * @return */ public static Singleton3 getInstance() &#123; if (instance == null) &#123; synchronized (Singleton3.class) &#123; if (instance == null) &#123; instance = new Singleton3(); &#125; &#125; &#125; return instance; &#125; /** * 防止反序列化创建新对象 * @return */ private Object readResolve() &#123; return instance; &#125;&#125; 静态内部类式单例线程安全，调用效率高，延时加载，推荐使用这种方式。 123456789101112131415161718192021222324252627282930public class Singleton4 implements Serializable &#123; /** * 创建静态内部类 */ private static class SingletonClassInstance &#123; private static final Singleton4 instance = new Singleton4(); &#125; /** * 私有化构造方法 */ private Singleton4() &#123; if (SingletonClassInstance.instance != null) &#123; throw new RuntimeException("重复创建单例对象"); &#125; &#125; public static Singleton4 getInstance() &#123; return SingletonClassInstance.instance; &#125; /** * 防止反序列化创建新对象 * * @return */ private Object readResolve() &#123; return SingletonClassInstance.instance; &#125;&#125; 枚举单例12345678910public enum Singleton5 &#123; INSTANCE; /** * 自定义操作 */ public void operation() &#123; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式概述]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[四人帮23种设计模式概述 什么是设计模式&emsp;&emsp;设计模式，是指在软件开发中，经过验证的，用于解决在特定环境下，重复出现的、特定问题的解决方案。通俗的说，就是解决特定问题的套路方法。 为什么要学设计模式 他山之石，可以攻玉。学习别人解决问题的思路，以后自己碰到了就可以很好的解决同样的问题。 提升逼格。让自己的代码更优雅，更有设计感。 如何学习设计模式 心态要稳，学习要狠。不要指望一步登天，心浮气躁。 理论与实践相结合。多写多思考，在实际开发中使用，然后再结合理论思考，然后再应用，再思考……如此循环，反复多次，直到达到对设计模式掌握的水平。 学习设计模式的三个层次鹦鹉学舌&emsp;&emsp;能够正确理解和掌握每个设计模式的基本知识，能够识别在什么场景下，出现了什么样的问题，采用何种方案解决它，并能够在实际的程序设计和开发中套用相应的设计模式。 照猫画虎&emsp;&emsp;能根据具体的实际情况，对设计模式进行适当的变形使用，能够确保正确使用设计模式，而不是生搬硬套。 学以致用&emsp;&emsp;真正的设计模式是没有模式。从本质上已经掌握了设计模式的精髓，并完全融入到了自己的思想中。在设计程序的时候，可以随意的，自然而然的运用。 上面基本都是废话，下面来点干货。 设计模式的六大原则开闭原则一个软件的实体(类、方法、模块等)，应该对扩展开放，对修改关闭。 依赖倒置原则高层模块不应该依赖底层模块，两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。 迪米特法则如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 单一职责原则一个类只做一种类型责任，当这个类需要承担其他类型的责任的时候，就需要分解这个类。 里氏替换原则接口或类出现的地方，他们的实现或者子类可以完全替换调他们。 接口隔离原则不要提供一个大的接口包含所有功能，要根据功能把这些接口分割，减少依赖。 设计模式分类创建型模式创建型模式有五种。 单例模式、工厂模式、建造者模式、原型模式、适配器模式。 结构型模式结构型模式有七种。 适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为模式行为模式有十一种。 模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo上传图片]]></title>
    <url>%2FHexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[自己写的简单客户端，解决上传到云图床的痛点。 之前的做法&emsp;&emsp;陆陆续续也写了有七八篇博客了，其他的感觉都还不错，就是图片上传体验并不愉快。我用的腾讯云图床存储图片，但我所使用的markdown编辑器并不提供上传图片的插件，腾讯云也没有客户端，只有网页版，所以只能是打开腾讯云后台上传图片，然后将图片的访问地址粘贴到编辑器中，刚开始感觉也不算什么麻烦事，但时间一长，来来回回的切换，就感觉不是那么方便了。 没有枪，没有炮，自己造。 &emsp;&emsp;既然咱是程序员，那就应该干点程序员该干的事，没有怎么办？自己写一个！ 开始干&emsp;&emsp;其实这个需求很简单，把文件传到服务器，返回个访问地址就可以了。想明白需求，那就简单了。然而，需求是明确了，痛处也来了——我并不熟悉桌面程序的写法😱。虽说干开发也有两年多了，但都是开发web项目，并没有写过桌面程序。只是刚刚接触Java时，学过一点点，但两年时间了，早就忘得一干二净了。 不过这点小困难可难不倒咱，正好身边有本书，那就现学现卖喽。 说起这本书，从买下到现在应该也有差不多四年了，也就刚刚买下那段时间看了看，现在基本都在吃灰，实在惭愧b(￣▽￣)d 扯远了，说正事。反正是逮着书一顿猛看，算是稍微有点印象了。然后着手开始写，写着写着，有些地方忘了，又回头看书，如此反反复复多次后，总算是有些样子了。写完抬起头看看窗外，天都黑了。 鲁迅曾说过： 有些时候，人总是将问题看的很简单，但当你去做的时候，发现其实并不是那么回事。 好吧，这句话是我编的，写程序都写出哲理了，感觉也是萌萌哒😵。 总之，不管怎么样，东西总算是做出来了，下面介绍下我的处女作。 程序基本介绍 如你所见，这个就是程序的主界面，功能简洁明了，遵循极简主义设计😂。下面介绍下使用方法： 选择文件点击选择文件按钮，弹出文件选择框，选中文件。 返回界面后，显示待上传文件列表 图片是单选的，如果要选多张图片，需要选多次。 好吧，我知道这点不好，本来做成了多选的，但那个多选文件的框太丑，而且不能预览图片，所以最终选择了这种方式。 上传文件上传没什么好说的，直接点击上传就可以了。 当没有选择文件，点击上传时： 历史记录显示上传历史。 未上传过文件，点击历史记录时： 清除内容清除主页面所有的显示。 清除内容不会清除历史，只会清除显示的文字。历史记录是存储在文本中的。 最后如果你我瞎鼓捣出的这个小玩意感兴趣，我打包好放到百度云盘了，下载就可以用，如果需要源码，直接邮箱联系我，我会抽时间发过去的。 软件使用时，需要在配置文件中配置自己的腾讯云相关参数。 点击这里下载]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>上传图片</tag>
        <tag>云图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo写作样式简介]]></title>
    <url>%2FHexo%E5%86%99%E4%BD%9C%E6%A0%B7%E5%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[使用Hexo中自带的写作样式，丰富文章表现形式 note标签修改主题配置文件_config.yml 12345note: style: flat icons: true border_radius: 3 light_bg_offset: 0 default 1&lt;div class="note default"&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt; primary 1&lt;div class="note primary"&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt; success 1&lt;div class="note success"&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt; info 1&lt;div class="note info"&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt; warning 1&lt;div class="note warning"&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt; danger 1&lt;div class="note danger"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; tabs标签选项卡 1选项卡 2选项卡 3选项卡 1 选项卡 2 这是选项卡 3 上面的，3表示打开页面时，默认展示第三个选项卡 1234567891011&#123;% tabs 选项卡, 3 %&#125;&lt;!-- tab --&gt;**选项卡 1**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**选项卡 2**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**这是选项卡 3**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 图标 照相机 电池 hexo 使用的是fontawesome图标，直接引用就可以 121. &lt;i class="fa fa-camera"&gt;&lt;/i&gt; 照相机2. &lt;i class="fa fa-battery-4"&gt;&lt;/i&gt; 电池 按钮google一下 1&#123;% btn https://www.google.com, google一下, google fa-fw %&#125;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>写作样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntelliJ IDEA 使用git]]></title>
    <url>%2FIntelliJ-IDEA-%E4%BD%BF%E7%94%A8git%2F</url>
    <content type="text"><![CDATA[介绍了IDEA中如何使用git IDEA中git的配置使用Ctrl+Alt+S打开设置 如图所示进行配置，配置完场后点击Test按钮，如果弹出版本号表示配置成功。 项目中使用gitgit检出项目 填写完地址后，点击Clone就可以检出项目了。 为项目添加git版本控制如图所示，为项目创建一个本地git版本库 选择当前项目文件夹，创建版本库 项目右键，将项目添加到版本控制中 提交项目到本地的仓库 填写提交说明，点击提交 连接到远程仓库 设置远程仓库位置 推送到远程仓库]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java String split的坑]]></title>
    <url>%2Fjava-String-split%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[一个关于Java String split方法的坑 Java的String中，有一个方法split() 1public String[] split(String regex) 这个方法根据给定的正则表达式，去切分目标字符串，并返回切分后的结果。 简单的测试代码： 123456@Testpublic void test1() &#123; System.out.println(Arrays.toString("1,2".split(",")));&#125;// 输出结果：[1, 2] 上面的代码，输出结果完全符合预期。然而，当把代码做如下修改时： 123456@Testpublic void test2() &#123; System.out.println(Arrays.toString("1.2".split(".")));&#125;// 输出结果：[] 难道不应该输出 [1, 2]吗？ 其实问题就出在split的参数上，在Java中，有些特殊符号输入时，是必须要转义的 \。 将参数改为\\.，就能输出正确结果了 123456@Testpublic void test3() &#123; System.out.println(Arrays.toString("1.2".split("\\.")));&#125;// 输出结果：[1, 2]]]></content>
      <categories>
        <category>踩坑记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由拆装箱引起的性能问题]]></title>
    <url>%2F%E7%94%B1%E6%8B%86%E8%A3%85%E7%AE%B1%E5%BC%95%E8%B5%B7%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Integer.valueOf与Integer.parseInt引发的性能问题 问题代码1int a = Integer.valueOf(request.getParameter("baseProjectId")) 这段代码看上去没什么问题，但其实会有性能上的浪费，Integer.valueOf()的部分源码： 12345678910public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10)); // 注意parseInt这句&#125;public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 由代码可以看出，Integer.valueOf() 先调用parseInt()解析字符串，然后再调用方法，将int转换为Integer对象，然后返回Integer对象。结合上面的问题代码，整个类型转换流程为： 1String --&gt; int --&gt; Integer --&gt; int 在此过程中，不仅创建了一个临时对象，浪费内存，而且进行了一次拆装箱操作，浪费了性能。 更改建议直接将Integer.valueOf()改为Integer.parseInt() 1int a = Integer.parseInt(request.getParameter("baseProjectId"))]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破解防盗链]]></title>
    <url>%2F%E7%A0%B4%E8%A7%A3%E9%98%B2%E7%9B%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[用简单粗暴的方式破解防盗链 什么是盗链简单来说，有两个网站，A和B。A网站有一张图片 1&lt;img src="http://xxx/a.png" /&gt; B网站看到了这张图片，他不下载，直接将图片的地址放到了自己的服务器上。那么当用户访问B站点时，实际却跑的是A站点的流量和服务，从而不劳而获，这就是盗链。 referrer为了解决这种事情，HTTP协议规定：浏览器在加载非本站资源时，会增加如下请求头： 1Referer: http://localhost:8080/temp/b.html 这个Referer标签是告诉请求者，引用这个资源的站点是谁 防盗链原理一般的站点，会根据Referer来进行防盗链工作，当请求头存在Referer时，即为非法引用，此时服务器拒绝服务，从而达到防盗链的目的。具体的实现有很多种，此处不细讲了，可自行Google。 破解防盗链了解了防盗链的基本原理后，破解就简单多了。只要想办法在请求的时候取消请求头中的Referer就可以了。这里破解也有好多种办法，可以使用nginx反向代理，或者使用iframe等等。这里介绍一种我认为相对来说最简单的办法： 1&lt;meta name="referrer" content="never"&gt; 只要在html中加入上面的meta标签，就可以破解简单的防盗链了。这个meta标签的意思是告诉浏览器，请求时不用包含referer相关的信息，从而达到破解防盗链的目的。 referer与referrer有人觉得很奇怪，浏览器中的请求头是referer，怎么标签里的是referrer，其实标签中的referrer才是正确的单词，据说是当时HTTP协议的制定者将单词拼错，大家就将错就错的使用了。具体可看维基百科的 HTTP来源地址 词条]]></content>
      <categories>
        <category>奇淫巧技</category>
      </categories>
      <tags>
        <tag>奇淫巧技</tag>
        <tag>防盗链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建git服务器]]></title>
    <url>%2F%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本地搭建git服务器 前言&emsp;&emsp;git可以说是目前使用最广泛的版本控制系统了，GitHub是基于git的免费的代码托管网站，有人说，既然都是免费的了，直接用不就好了吗，干嘛还要费劲自己搭建一个服务。我想说的是，GitHub虽然是免费的，但是有一点很重要，那就是私有性。公司内部的项目通常都是要保密的。虽然GitHub可以选择仓库私有，但那是要收费的。综上所述，还是在自己私有的服务器上搭建git服务比较合适。 &emsp;&emsp;本次演示使用VMware虚拟机，系统镜像CentOS 6.9 x64，root账户进行安装操作。 正文开始安装git使用yum查询当前是否有可安装的git版本 1[root@hadoop03 home]# yum info git 使用yum安装git 1[root@hadoop03 ~]# yum install -y git 检查是否安装成功 12[root@hadoop03 ~]# git versiongit version 1.7.1 创建git运行用户1[root@hadoop03 ~]# adduser git 在当前Linux系统中创建了一个新的用户git。 执行完以上命令后，会在/home生成一个git文件夹。我们cd到home目录查看一下 123[root@hadoop03 git]# cd /home/git[root@hadoop03 git]# ls -a. .. .bash_logout .bash_profile .bashrc .gnome2 .mozilla 禁止git用户shell登录创建git用户是为了访问服务器的git仓库，为了安全起见，将git用户禁止shell登录。 1[root@hadoop03 ~]# vi /etc/passwd 找到类似下面的一句 1git:x:501:501::/home/git:/bin/bash 将其改为 1git:x:501:501::/home/git:/usr/bin/git-shell 保存即可 创建ssh证书登录在/home/git文件夹下，创建一个新文件夹.ssh，并新建一个文件authorized_keys，这个authorized_keys文件用来存放我们的git公钥。 12345[root@hadoop03 git]# mkdir .ssh[root@hadoop03 git]# cd .ssh[root@hadoop03 .ssh]# touch authorized_keys[root@hadoop03 .ssh]# lsauthorized_keys 收集团队中其他人的git公钥，复制后添加到authorized_keys文件中。git公钥一般存放在C:\Users\xxx\.ssh\id_rsa.pub中。如果你的电脑上没有，需要安装git客户端，并生成git公钥。关于此部分，我的另一篇博客使用GitHub-Pages-Hexo-搭建博客中有所介绍，此处不再细讲。 1[root@hadoop03 git]# vim authorized_keys 粘贴公钥后，保存即可。 注意：粘贴公钥时，注意空格。公钥一行一个。 初始化git仓库创建一个仓库目录，我放在/home/gitrepo下面 123[root@hadoop03 home]# mkdir gitrepo[root@hadoop03 home]# lsgit gitrepo 初始化git仓库，假设项目名叫test 123[root@hadoop03 home]# cd gitrepo/[root@hadoop03 gitrepo]# git init --bare test.gitInitialized empty Git repository in /home/gitrepo/test.git/ 执行完命令后，会在gitrepo下生成test.git目录 12[root@hadoop03 gitrepo]# lstest.git 修改仓库的归属权限，否则无法访问git仓库 1[root@hadoop03 gitrepo]# chown -R git:git test.git/ 至此，git服务器搭建完成。 克隆远程仓库1234λ git clone git@192.168.213.130:/home/gitrepo/test.gitCloning into 'test'...key_load_public: invalid formatwarning: You appear to have cloned an empty repository. 接下来就尽情使用git吧。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub Pages + Hexo 搭建博客]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[使用Github Pages + Hexo 自建博客的详细流程。包括创建GitHub账号，创建仓库，设置git客户端连接，ssh公钥，安装配置Hexo并部署，设置Hexo next主题，自定义域名。 折腾了近一个星期，终于将博客搭建成功了，现在将具体的过程写出来，以帮助需要自建博客的人。 GitHub部分注册GitHub账号要使用GitHub Pages，需要先注册GitHub账号，注册链接 注册流程就不细说了，相信大家都会注册的。 注册完成后，需要邮箱激活，请进入自己的注册邮箱，完成激活即可。 创建Git仓库Git repository(仓库) 用于存放博客内容 上面的按钮随便点击一个都可以跳转到创建仓库页面 私有仓库是收费的，公共仓库是免费的，这个根据情况自己选择即可。 仓库设置仓库创建成功后，进入仓库主页 点击进入仓库设置 如果创建时仓库名字是 自己的用户名.github.io，则以上的选项默认是选中的。 至此，创建仓库就完成了，此时打开浏览器，输入 自己的用户名.github.io就能访问自己的主页了。 安装Git客户端仓库创建完成后，需要安装Git客户端与Git仓库进行连接，方便我们在本地提交博客。 根据自己的操作系统，下载git客户端 ，完成安装。 设置git环境变量打开git的安装目录，并复制安装路径。 桌面上找到我的电脑 – &gt; 右键 –&gt; 属性 –&gt; 高级系统设置 –&gt; 环境变量 –&gt; 系统变量 –&gt; Path 新建变量值，将刚刚复制的路径填进去，并在末尾加上\cmd，保存即可 测试环境变量是否配置成功，打开命令行输入 1git version 输出版本号，表示配置成功。 设置用户名和邮箱鼠标点击右键，选择Git Bash Here，打开git bash客户端 12git config --global user.name "zhangsan"git config --global user.email "zhangsan@sina.com" 生成ssh密钥1ssh-keygen -t rsa -C "zhangsan@sina.com" 连续回车即可。 设置GitHub公钥打开目录C:\Users\你自己的用户名\.ssh下，会有两个文件 id_rsa(私钥) id_rsa.pub(公钥) ，使用文本编辑器打开id_rsa.pub，复制里面的内容，登录GitHub，进入个人设置中心。 开始设置ssh 新建ssh key 填入公钥 点击 Add SSH key就可以了。 在本地测试连接 1ssh -T git@github.com 当输出以下内容时，表示连接成功。 Hexo部分安装nodejs根据自己的操作系统平台，下载nodejs，并安装。 nodejs环境变量安装好后，会自己添加到环境变量中，一般不需设置。 设置node环境变量和git环境变量类似，请参考git环境变量的配置。 注意：此处编辑变量值时，不需要在后面加\cmd，直接复制路径即可。 配置完成后，命令行输入 1node --version 输出版本号，表示配置成功。 安装Hexo使用npm安装Hexo，npm是nodejs自带的包依赖管理工具，类似于Centos中的yum。 1npm install -g hexo-cli 强烈建议浏览 Hexo官方文档，写的非常详细。 初始化博客123hexo init 自定义文件夹cd 自定义文件夹npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml #博客的全局配置文件├── package.json #包含了应用程序的信息├── scaffolds #模板文件夹├── source #用户资源文件夹| ├── _drafts #草稿箱| └── _posts #写的文章放到这里└── themes #主题文件夹 _config.yml文件详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo #网站标题subtitle: #网站副标题description: #网站描述keywords: #关键字author: John Doe #网站作者language: #网站所使用的语言 中文使用 zh-Hans 防止乱码timezone: #网站时区 Asia/Shanghai# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com #网址root: / #网站根目录permalink: :year/:month/:day/:title/ #文章的 永久链接 格式permalink_defaults: #永久链接中各部分的默认值# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 # http://yoursite.com/blog 并把 root 设为 /blog/。# Directorysource_dir: source #资源文件夹，这个文件夹用来存放内容。public_dir: public #公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags #标签文件夹archive_dir: archives #归档文件夹category_dir: categories #分类文件夹code_dir: downloads/code #Include code 文件夹i18n_dir: :lang #国际化（i18n）文件夹skip_render: #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 # Writingnew_post_name: :title.md #新文章的文件名称default_layout: post #预设布局titlecase: false #把标题转换为 title caseexternal_link: true #在新标签中打开链接filename_case: 0 #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false #显示草稿post_asset_folder: false #启动 Asset 文件夹relative_link: false #把链接改为与根目录的相对位址future: true #显示未来的文章highlight: #代码块的设置 enable: true #是否开启代码块支持 line_number: true #显示行号 auto_detect: false tab_replace: #设置用什么字符替代Tab，如tab_replace: aaa，在代码中将输入tab的地方替换为aaa # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorized #默认分类category_map: #分类别名tag_map: #标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD #日期格式time_format: HH:mm:ss #时间格式# Pagination## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章条数pagination_dir: page #分页目录# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape #当前所使用的主题名# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: #部署部分设置 type: #部署类型 根据需要更改配置文件，进行个性化配置 启动Hexo服务初始化完成后，就可以启动Hexo服务了，进入博客目录，执行以下命令，即可启动服务 12hexo g #生成静态文件hexo s #启动hexo服务 打开浏览器，输入http://localhost:4000/ 配置了这么长时间，终于看到点效果了，有没有很激动O(∩_∩)O Hexo基本命令1234567hexo generate #生成静态文件，可以简写为 hexo ghexo clean #清除生成的静态文件hexo server #启动hexo服务进行预览，可以简写为 hexo shexo deploy #部署到服务器，可以简写为hexo dhexo new "文件名" #创建新文章hexo new draft "文件名" #创建草稿箱文章hexo new page "页面名" #创建新页面 配置部署到GitHub更改_config.yml配置文件的deploy部分。 1234deploy: type: git repo: https://github.com/xxx/xxx.github.io.git branch: master #部署的分支 或者 1234deploy: type: git repo: git@github.com:xxx/xxx.github.io.git branch: master #部署的分支 部署到GitHub1hexo d 自定义域名首先要有注册好的域名，没有的话，可以先去注册。域名的注册这里不多介绍了，资料很多，大家可以自己选择域名注册商进行注册。 CNAME类型解析注册好域名后，在博客的资源文件夹source下创建一个文件，CNAME，注意，这个文件没有后缀。使用文本编辑器打开，填入自己的域名，并保存。 登录自己的域名解析后台，添加一条解析记录。记录类型选择CNAME，记录值填入之前GItHub分配的访问路径xxx.github.io，保存后就可以用自己的域名访问博客了。 注意：CNAME文件一定要放在source路径下，否则下次部署的时候，CNAME就被删除了。 A类型解析在自己的域名解析后台添加一条解析记录，记录类型选择A，记录值填写自己项目访问路径的IP地址。如果不清楚IP地址，可以通过ping 项目访问路径的方式获得，然后填入记录值中即可。 Hexo更换next主题安装next主题建议根据官方文档安装，遇到不明白的地方再找别的资料参考 next官方文档 Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。 cd 到你的博客路径下，使用git下载主题文件 1git clone https://github.com/iissnan/hexo-theme-next themes/next 修改博客配置文件_config.yml，将theme: landscape修改为theme: next 启动服务即可。 上面的界面是我美化后的效果，图片仅供参考。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>自建博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要写博客]]></title>
    <url>%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[关于写博客，自建博客的一些个人看法 写博客的原因记录解决问题的步骤，方便查阅&emsp;&emsp;首先作为程序员来讲，工作中都会遇到很多自己解决不了的问题。很多时候自己都是习惯去Google，或者各个博客看别人的解决办法，然后尝试解决问题。在这个过程中，发现很多人写的都是错误的，经常是按照A写的做，做完发现不对，又按照B写的做，发现又不对…… 最后终于将问题解决了，过一段时间遇到相同的问题，却又想不起来当初是怎么解决的。有了博客，就可以记录查阅了。 知识，只有自己总结后，才是自己的&emsp;&emsp;俗话说眼过千遍，不如手过一遍。这句话在编程界尤为适用。某个知识点，看着别人写的，感觉自己都会了，等到自己动手写的时候，脑子里空空如也，半棍子打不出一个屁来。有了博客，在写博客的时候，就会强迫自己将知识点深入理解，也算是知识梳理的过程吧。 提高写作水平&emsp;&emsp;其实自己一直有一个写作的梦想，当年读高中时，还曾经写过一本侦探小说🤣。写博客，可以练习练习语言组织能力，天天写代码，有时候连话都说不太清了。 自建博客的原因不信任第三方博客&emsp;&emsp;网络世界错综复杂，各个博客平台此消彼长。说不定到那一天，自己所在的平台就消失了，到时候当初自己辛辛苦苦写的东西也就随之消失。这是一件非常痛心的事情。 自己的地盘，可以尽情折腾&emsp;&emsp;大概程序员都喜欢自己折腾吧。自建博客，所有的东西都是自己说了算，感觉非常自由。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
